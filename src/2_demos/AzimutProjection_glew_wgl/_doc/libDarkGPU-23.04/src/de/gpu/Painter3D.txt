// #include <de/gpu/MSAA.hpp>
// #include <de/gpu/ScreenRenderer.hpp>
// #include <de/gpu/Font5x8Renderer.hpp>
// #include <de/gpu/PerfOverlay.hpp>
// #include <de/gpu/Billboard3DRenderer.hpp>

   // EGLDisplay m_eglDisplay;   ///< Selected display - Currently used EGL display
   // EGLConfig m_eglConfig;   ///< Selected config - Currently used EGL config
   // EGLSurface m_eglSurface;   ///< Selected surface - Currently used EGL surface
   // EGLContext m_eglContext;   ///< Selected context - Currently used EGL context

#ifdef USE_LIB_DARKFONT
//   FontRenderer m_FontRenderer;              // 2D truetype font renderer ( textured quad per glyph, tex atlas approach )
#endif

//   PerfOverlay m_PerfOverlay;                // 2D TextOverlay
//   Draw2DDemo m_Demo2D;
//   UI m_GUIEnvironment;
//   SceneManager m_SceneManager;

   // Water3DRenderer m_Water3DRenderer;
   // CollisionManager m_CollisionManager;
   // LineRenderer m_LineRenderer;
   // StippleLineRenderer m_StippleLineRenderer;


   // Camera control
   // std::array< bool, 256 > m_KeyStates;
   // SM3< int32_t > m_MouseX;   // Mouse Pos X
   // SM3< int32_t > m_MouseY;   // Mouse Pos Y
   // int32_t m_MouseMoveX;
   // int32_t m_MouseMoveY;

   // bool m_IsDragging;
   // bool m_LMB; // left mb pressed
   // bool m_RMB;
   // bool m_MMB;



   // typ = 0 -> MeshBuffers per Frame
   // typ = 1 -> Vertices per Frame
   // typ = 2 -> Indices per Frame
   // typ = 3 -> Primitives per Frame
   // typ = 4 -> Total rendered Frames
   // typ = 5 -> Total rendered MeshBuffers
   // typ = 6 -> Total rendered Vertices
   // typ = 7 -> Total rendered Indices
   // typ = 8 -> Total rendered Primitives
   uint64_t getRenderStat( int typ = 0 ) const;
#ifdef USE_LIB_DARKFONT
   void
   draw2DText(
      int x,
      int y,
      std::wstring const & msg,
      uint32_t color = 0xFF000000,
      Align::EAlign align = Align::Default,
      Font const & font = Font() )
   {
      m_FontRenderer.draw2DText( x, y, msg, color, align, font );
   }

   void
   draw2DPerfOverlay() { m_PerfOverlay.draw2DPerfOverlay(); }

#endif

// ###########################
// ###                     ###
// ###   FontRenderer5x8   ###
// ###                     ###
// ###########################
   glm::ivec2
   getTextSize5x8(
      std::string const & msg,
      Font5x8 const & font = Font5x8() )
   {
      return m_Font5x8Renderer.getTextSize( msg, font );
   }

   void
   draw2DText5x8(
      int x,
      int y,
      std::string const & msg,
      uint32_t color = 0xFF000000,
      Align::EAlign align = Align::Default,
      Font5x8 const & font = Font5x8() )
   {
      m_Font5x8Renderer.draw2DText( x, y, msg, color, align, font );
   }

   void
   draw2DPerfOverlay5x8()
   {
      m_PerfOverlay.draw2DPerfOverlay5x8();
   }


// ###############################################################
// ###                                                         ###
// ###  Geometry class independent 2D/3D material renderering  ###
// ###                                                         ###
// ###############################################################
   void
   draw2D( IMeshBuffer & buf ) override
   {
      if ( !buf.isVisible() ) return;
      m_ScreenRenderer.setMaterial( buf.getMaterial() );
      buf.draw();
      m_ScreenRenderer.unsetMaterial( buf.getMaterial() );
   }

   void
   draw3D( IMeshBuffer & buf ) override
   {
      if ( !buf.isVisible() ) return;
      m_MaterialRenderer.setMaterial( buf.getMaterial() );
      buf.draw();
      m_MaterialRenderer.unsetMaterial( buf.getMaterial() );
   }

   void
   draw3D( IMeshBuffer & buf, std::vector< glm::mat4 > const & instances ) override
   {
      if ( !buf.isVisible() ) return;
      m_MaterialRenderer.setMaterial( buf.getMaterial() );
      buf.draw();
      m_MaterialRenderer.unsetMaterial( buf.getMaterial() );
   }

// ###########################
// ###                     ###
// ###   ScreenRenderer    ###
// ###                     ###
// ###########################
   void
   draw2DLine( float x1, float y1, float x2, float y2, uint32_t color, float z = 0.0f ) override
   {
      draw2DLine( x1, y1, x2, y2, color, color, z );
   }

   void
   draw2DLine( float x1, float y1, float x2, float y2, uint32_t colorA, uint32_t colorB, float z = 0.0f ) override
   {
      SMeshBuffer o( PrimitiveType::Lines );
      o.Name = "Driver::draw2DLine";
      o.setLighting( 0 );
      if ( RGBA_A( colorA ) == 255 && RGBA_A( colorB ) == 255 )
      {
         o.setBlend( Blend::disabled() );
      }
      else
      {
         o.setBlend( Blend::alphaBlend() );
      }
      o.Vertices.reserve( 2 );
      o.Vertices.push_back( S3DVertex( x1, y1, z, 0.f, 0.f, 0.f, colorA, 0,0 ) ); // A
      o.Vertices.push_back( S3DVertex( x2, y2, z, 0.f, 0.f, 0.f, colorB, 0,0 ) ); // B
      draw2D( o );
   }

   //
   //  B +-----+ C --> +x, +u
   //    |   / |
   //    | /   |     FrontQuad ABCD (cw) = ABC (cw) + ACD (cw)
   //  A +-----+ D
   //    |           Normal -z shows towards viewer
   //   +v = -y      Pos.z is always -1, so its at near plane.
   //

   void
   draw2DRect( Recti const & pos,
        uint32_t colorA, uint32_t colorB, uint32_t colorC, uint32_t colorD,
               TexRef const & ref = TexRef() ) override
   {
      if( pos.getWidth() < 1 ) { return; }
      if( pos.getHeight() < 1 ) { return; }
      SMeshBuffer o;
      SMeshRect::add( o, pos, colorA, colorB, colorC, colorD, ref );
      o.Name = "Driver::draw2DRect";
      o.setCulling( false );
      draw2D( o );
   }

   void
   draw2DRect( Recti const & pos,
               uint32_t color = 0xFFFFFFFF,
               TexRef const & ref = TexRef() ) override
   {
      draw2DRect( pos, color, color, color, color, ref );
   }

   void
   draw2DRectOutline(
         Recti const & pos,
         uint32_t colorA, uint32_t colorB, uint32_t colorC, uint32_t colorD,
         TexRef const & ref = TexRef(),
         int borderWidth = 1 ) override
   {
      if( pos.getWidth() < 1 ) { return; }
      if( pos.getHeight() < 1 ) { return; }
      SMeshBuffer o;
      glm::vec2 A(pos.x,pos.y);
      glm::vec2 B(pos.x,pos.y);
      glm::vec2 C(pos.x,pos.y);
      glm::vec2 D(pos.x,pos.y);
      SMeshPolyLine::addExtrudedLine( o, A,B, colorA, colorB, borderWidth );
      SMeshPolyLine::addExtrudedLine( o, B,C, colorB, colorC, borderWidth );
      SMeshPolyLine::addExtrudedLine( o, C,D, colorC, colorD, borderWidth );
      SMeshPolyLine::addExtrudedLine( o, D,A, colorD, colorA, borderWidth );
      o.Name = "Driver::draw2DRectOutline";
      o.setCulling( false );
      if ( ref.tex ) o.setTexture( 0, ref );
      draw2D( o );
   }

   void
   draw2DRectOutline(
      Recti const & pos,
      uint32_t color = 0xFFFFFFFF,
      TexRef const & ref = TexRef(), int borderWidth = 1 ) override
   {
      if( pos.getWidth() < 1 ) { return; }
      if( pos.getHeight() < 1 ) { return; }
      SMeshBuffer o;
      SMeshRect::addOutline( o, pos, color, ref, borderWidth );
      o.Name = "Driver::draw2DRectOutline";
      o.setCulling( false );
      draw2D( o );
   }

   void
   draw2DRoundRect(
      Recti const & pos,
      float rx, float ry,
      uint32_t color = 0xFFFFFFFF,
      TexRef const & tex = TexRef(),
      int tess = 13 ) override
   {
      int w = pos.getWidth();
      int h = pos.getHeight();
      if ( w < 3 ) { return; }
      if ( h < 3 ) { return; }
      SMeshBuffer o;
      addRoundRect( o, pos, glm::ivec2(rx,ry), color, color, tex, tess );
      o.Name = "Driver::draw2DRoundRect";
      o.setCulling( false );
      draw2D( o );
   }

   void
   draw2DRoundRectOutline(
      Recti const & pos,
      float rx, float ry,
      uint32_t color = 0xFFFFFFFF,
      TexRef const & tex = TexRef(),
      int borderWidth = 1,
      int tess = 13 ) override
   {
      int w = pos.getWidth();
      int h = pos.getHeight();
      if ( w < 3 ) { return; }
      if ( h < 3 ) { return; }
      SMeshBuffer o;
      addRoundRectOutline( o, pos, glm::ivec2(rx,ry), color, tex, tess );
      o.Name = "Driver::draw2DRoundRectOutline";
      o.setCulling( false );
      draw2D( o );
   }

   void
   draw2DCircle(
      Recti const & pos,
      uint32_t color = 0xFFFFFFFF,
      TexRef const & tex = TexRef(),
      int tess = 36 ) override
   {
      int w = pos.getWidth();
      int h = pos.getHeight();
      if ( w < 1 ) { return; }
      if ( h < 1 ) { return; }
      SMeshBuffer o;
      o.Name = "Driver::draw2DCircle";
      addCircle( o, pos, color, color, tex, tess );
      draw2D( o );
   }

   void
   draw2DCircleOutline(
      Recti const & pos, uint32_t color = 0xFFFFFFFF,
      TexRef const & tex = TexRef(),
      int borderWidth = 1,
      int tess = 36 ) override
   {
      int w = pos.getWidth();
      int h = pos.getHeight();
      if ( w < 1 ) { return; }
      if ( h < 1 ) { return; }
      SMeshBuffer o;
      o.Name = "Driver::draw2DCircleOutline";
      addCircleOutline( o, pos, color, tex, borderWidth, tess );
      draw2D( o );
   }
