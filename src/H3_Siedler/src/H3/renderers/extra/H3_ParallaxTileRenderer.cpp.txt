#include "H3_ParallaxTileRenderer.h"
#include <H3/H3_Game.h>
#include <de_opengl.h>

H3_TileParallaxRenderer::H3_TileParallaxRenderer()
{
    m_shader = nullptr;
    m_texture2DArray = 0;
    m_vao = 0;
}
H3_TileParallaxRenderer::~H3_TileParallaxRenderer() {}

void H3_TileParallaxRenderer::init(de::VideoDriver* driver, const H3_Game& board)
{
    m_driver = driver;

    // Create shader
    if (!m_shader)
    {
        std::string vs = R"(

            // ===============================================
            /// @brief The Hexagon
            // ===============================================
            ///
            ///               M| x=0 | y=0 | z=0 | u=.5| v=.5|
            ///       D       -|-----|-----|-----|-----|-----|
            ///      / \      A|   0 |  0  | -.5 | .5  | 0   |
            ///   C /   \ E   B| -.5 |  0  |-.25 |  0  | 0.25|
            ///    |-----|    C| -.5 |  0  | .25 |  0  | 0.75|
            ///    |  M  |    D| 0.0 |  0  |  .5 |  .5 | 1   |
            ///    |-----|    E| 0.5 |  0  | .25 |  1  | 0.75|
            ///   B \   / F   F| 0.5 |  0  |-.25 |  1  | 0.25|
            ///      \ /
            ///       A       triangles: BFA, BEF, BCE, CDE
            ///

            layout(location = 0) in mat4 a_instanceMat; // (mat4 spans 4 attribute locations)
            layout(location = 4) in float a_instanceLayer; // index into texture2DArray
            layout(location = 5) in float a_instanceAngle60; // index into uvcoords

            uniform mat4 u_projViewMat;

            out vec2 v_texCoord;
            flat out int v_layer;

            const vec2 a_position[6] = vec2[](
                vec2( 0.00, -0.50), // A=0
                vec2(-0.50, -0.25), // B=1
                vec2(-0.50,  0.25), // C=2
                vec2( 0.00,  0.50), // D=3
                vec2( 0.50,  0.25), // E=4
                vec2( 0.50, -0.25)  // F=5
            );

            const vec2 a_texcoord[6] = vec2[](
                vec2( 0.50, 1.00),  // A=0
                vec2( 0.00, 0.75),  // B=1
                vec2( 0.00, 0.25),  // C=2
                vec2( 0.50, 0.00),  // D=3
                vec2( 1.00, 0.25),  // E=4
                vec2( 1.00, 0.75)   // F=5
            );

            const uint a_indices[12] = uint[](
                1, 5, 0, // BFA
                1, 4, 5, // BEF
                1, 2, 4, // BCE
                2, 3, 4  // CDE
            );

            void main() {
                const uint i = a_indices[gl_VertexID];

                const uint k = (i + uint(a_instanceAngle60)) % 6;

                v_texCoord = a_texcoord[k];

                v_layer = int(a_instanceLayer);

                const float x = a_position[i].x;

                const float z = a_position[i].y;

                gl_Position = u_projViewMat * a_instanceMat * vec4(x, 0.0, z, 1.0);
            }
            )";

        // Fragment Shader Source
        std::string fs = R"(

                in vec2 v_texCoord;

                flat in int v_layer;

                out vec4 fragColor;

                //uniform sampler2D u_diffuseMap;

                uniform sampler2DArray u_diffuseMapArray;

                // uniform int u_layerIndex;

                void main()
                {
                    // fragColor = texture(u_diffuseMap, v_texCoord);

                    fragColor = texture(u_diffuseMapArray, vec3(v_texCoord, v_layer));
                }
            )";


        std::string const & shaderName = "HexTile";

        m_shader = m_driver->createShader( shaderName, vs, fs );
    }

    // Create textures:
    if (!m_texture2DArray)
    {
        const int w = 256;
        const int h = 256;
        const int layers = 8;
        std::vector<uint8_t> pixels( w * h * layers * 4);

        drawGradient(pixels.data(), w, h, 0,  50,  50,  50,  10,  10,  10); // Unknown
        drawGradient(pixels.data(), w, h, 1,  50,  50, 100, 150, 150, 255); // Water + Ports
        drawGradient(pixels.data(), w, h, 2, 255, 255, 200, 255, 255, 150); // Desert
        drawGradient(pixels.data(), w, h, 3, 100, 200, 100,  50, 100,  50); // A
        drawGradient(pixels.data(), w, h, 4, 255, 155, 100, 200, 100, 100); // B
        drawGradient(pixels.data(), w, h, 5, 150, 255, 150, 100, 155, 100); // C
        drawGradient(pixels.data(), w, h, 6, 255, 255, 150, 150, 150,  50); // D
        drawGradient(pixels.data(), w, h, 7, 190, 190, 190,  20,  20,  20); // E

        glGenTextures(1, &m_texture2DArray);
        GL_VALIDATE;
        glActiveTexture( GL_TEXTURE0 );
        GL_VALIDATE;
        glBindTexture(GL_TEXTURE_2D_ARRAY, m_texture2DArray);
        GL_VALIDATE;
        glTexImage3D(GL_TEXTURE_2D_ARRAY, 0, GL_RGBA, w, h, layers, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());
        GL_VALIDATE;
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        GL_VALIDATE;
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        GL_VALIDATE;
        glBindTexture(GL_TEXTURE_2D_ARRAY, 0);
        GL_VALIDATE;
    }
}

void H3_TileParallaxRenderer::upload(const H3_Game& board)
{
    const size_t n = board.m_tiles.size();

    // Instance Data (Transform Matrices)
    m_instanceMat.clear();
    m_instanceMat.reserve(n);
    m_instanceLayer.clear();
    m_instanceLayer.reserve(n);
    m_instanceAngle60.clear();
    m_instanceAngle60.reserve(n);
    for (size_t k = 0; k < n; ++k)
    {
        const auto& tile = board.m_tiles[k];
        m_instanceMat.push_back( tile.trs.trs );

        // [Textures]:
        int layer = 0; // Unknown tex (question mark on black background)
        switch( tile.cfg.tileType.value )
        {
            case H3_TileType::Water: layer = 1; break;
            case H3_TileType::Desert: layer = 2; break;
            case H3_TileType::TileA: layer = 3; break;
            case H3_TileType::TileB: layer = 4; break;
            case H3_TileType::TileC: layer = 5; break;
            case H3_TileType::TileD: layer = 6; break;
            case H3_TileType::TileE: layer = 7; break;
            case H3_TileType::PortA: layer = 1; break;
            case H3_TileType::PortB: layer = 1; break;
            case H3_TileType::PortC: layer = 1; break;
            case H3_TileType::PortD: layer = 1; break;
            case H3_TileType::PortE: layer = 1; break;
            case H3_TileType::Port3v1: layer = 1; break;
            default: layer = 0; break;
        }

        m_instanceLayer.emplace_back( layer );

        m_instanceAngle60.emplace_back( tile.cfg.angle60 );
    }






    if (!m_vao)
    {
        glGenVertexArrays(1, &m_vao);
        DE_TRACE("m_vao = ",m_vao)
    }

    glBindVertexArray(m_vao);
    //GL_VALIDATE;

    // vbo_instanceMat:
    if (!vbo_instanceMat)
    {
        glGenBuffers(1, &vbo_instanceMat);
        //DE_TRACE("vbo_instanceMat = ",vbo_instanceMat)
    }
    glBindBuffer(GL_ARRAY_BUFFER, vbo_instanceMat);
    //GL_VALIDATE;

    glBufferData(GL_ARRAY_BUFFER, m_instanceMat.size() * sizeof(glm::mat4), m_instanceMat.data(), GL_STATIC_DRAW);
    //GL_VALIDATE;

    // Set up the instance matrix attribute (mat4 spans 4 attribute locations)
    for (int i = 0; i < 4; i++)
    {
        glVertexAttribPointer(i, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float) * i * 4));
        GL_VALIDATE;
        glVertexAttribDivisor(i, 1); // Update per instance
        GL_VALIDATE;
        glEnableVertexAttribArray(i);
        GL_VALIDATE;
    }

    // vbo_instanceLayer:
    if (!vbo_instanceLayer)
    {
        glGenBuffers(1, &vbo_instanceLayer);
        DE_TRACE("vbo_instanceLayer = ",vbo_instanceLayer)
    }
    glBindBuffer(GL_ARRAY_BUFFER, vbo_instanceLayer);
    GL_VALIDATE;
    glBufferData(GL_ARRAY_BUFFER, m_instanceLayer.size() * sizeof(uint8_t), m_instanceLayer.data(), GL_STATIC_DRAW);
    GL_VALIDATE;
    glVertexAttribPointer(4, 1, GL_UNSIGNED_BYTE, GL_FALSE, sizeof(uint8_t), (void*)0);
    GL_VALIDATE;
    glVertexAttribDivisor(4, 1); // Per-instance divisor
    GL_VALIDATE;
    glEnableVertexAttribArray(4);
    GL_VALIDATE;

    // vbo_instanceAngle60:
    if (!vbo_instanceAngle60)
    {
        glGenBuffers(1, &vbo_instanceAngle60);
        DE_TRACE("vbo_instanceAngle60 = ",vbo_instanceAngle60)
    }
    glBindBuffer(GL_ARRAY_BUFFER, vbo_instanceAngle60);
    GL_VALIDATE;
    glBufferData(GL_ARRAY_BUFFER, m_instanceAngle60.size() * sizeof(uint8_t), m_instanceAngle60.data(), GL_STATIC_DRAW);
    GL_VALIDATE;
    glVertexAttribPointer(5, 1, GL_UNSIGNED_BYTE, GL_FALSE, sizeof(uint8_t), (void*)0);
    GL_VALIDATE;
    glVertexAttribDivisor(5, 1); // Per-instance divisor
    GL_VALIDATE;
    glEnableVertexAttribArray(5);
    GL_VALIDATE;

    glBindVertexArray(0);
    GL_VALIDATE;
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    GL_VALIDATE;
}

// Function to generate gradient textures
void H3_TileParallaxRenderer::drawGradient(uint8_t* data, int w, int h, int layer,
                  uint8_t r1, uint8_t g1, uint8_t b1,
                  uint8_t r2, uint8_t g2, uint8_t b2)
{
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            float t = static_cast<float>(y) / (h - 1);
            data[(layer * w * h + y * w + x) * 4 + 0] = r1 * (1 - t) + r2 * t;
            data[(layer * w * h + y * w + x) * 4 + 1] = g1 * (1 - t) + g2 * t;
            data[(layer * w * h + y * w + x) * 4 + 2] = b1 * (1 - t) + b2 * t;
            data[(layer * w * h + y * w + x) * 4 + 3] = 255;
        }
    }
}

void H3_TileParallaxRenderer::render( glm::mat4 const & projViewMat )
{
    if (!m_vao)
    {
        return;
    }

    de::State state;
    state.culling = de::Culling::disabled();
    state.blend = de::Blend::alphaBlend();
    m_driver->setState( state );

    glUseProgram(m_shader->id);
    GL_VALIDATE;

    glActiveTexture( GL_TEXTURE0);
    GL_VALIDATE;
    glBindTexture( GL_TEXTURE_2D_ARRAY, m_texture2DArray );
    GL_VALIDATE;

    m_shader->setMat4f( "u_projViewMat", projViewMat );

    m_shader->setInt( "u_diffuseMapArray", 0 );

    glBindVertexArray(m_vao);
    GL_VALIDATE;
    glDrawArraysInstanced(GL_TRIANGLES, 0, 12, m_instanceMat.size());
    GL_VALIDATE;
    glBindVertexArray(0);
    GL_VALIDATE;
    glBindTexture( GL_TEXTURE_2D_ARRAY, 0 );
    GL_VALIDATE;
}
