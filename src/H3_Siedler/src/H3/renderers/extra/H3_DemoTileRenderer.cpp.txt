#include "H3_DemoTileRenderer.h"
#include <H3/H3_Game.h>
#include <de_opengl.h>

H3_DemoTileRenderer::H3_DemoTileRenderer()
{
    m_shader = nullptr;
    m_texture2DArray = 0;
    m_vao = 0;
}
H3_DemoTileRenderer::~H3_DemoTileRenderer() {}

void H3_DemoTileRenderer::init(de::VideoDriver* driver)
{
    m_driver = driver;

    // Create shader
    if (!m_shader)
    {
        std::string vs = R"(

            // ===============================================
            /// @brief The Hexagon
            // ===============================================
            ///
            ///               M| x=0 | y=0 | z=0 | u=.5| v=.5|
            ///       D       -|-----|-----|-----|-----|-----|
            ///      / \      A|   0 |  0  | -.5 | .5  | 0   |
            ///   C /   \ E   B| -.5 |  0  |-.25 |  0  | 0.25|
            ///    |-----|    C| -.5 |  0  | .25 |  0  | 0.75|
            ///    |  M  |    D| 0.0 |  0  |  .5 |  .5 | 1   |
            ///    |-----|    E| 0.5 |  0  | .25 |  1  | 0.75|
            ///   B \   / F   F| 0.5 |  0  |-.25 |  1  | 0.25|
            ///      \ /
            ///       A       triangles: BFA, BEF, BCE, CDE
            ///

            layout(location = 0) in mat4 a_instanceMat; // (mat4 spans 4 attribute locations)
            layout(location = 4) in float a_instanceLayer; // index into texture2DArray
            layout(location = 5) in float a_instanceAngle60; // index into uvcoords

            uniform mat4 u_projViewMat;

            out vec2 v_texCoord;
            flat out int v_layer;

            const vec2 a_position[6] = vec2[](
                vec2( 0.00, -0.50), // A=0
                vec2(-0.50, -0.25), // B=1
                vec2(-0.50,  0.25), // C=2
                vec2( 0.00,  0.50), // D=3
                vec2( 0.50,  0.25), // E=4
                vec2( 0.50, -0.25)  // F=5
            );

            const vec2 a_texcoord[6] = vec2[](
                vec2( 0.50, 1.00),  // A=0
                vec2( 0.00, 0.75),  // B=1
                vec2( 0.00, 0.25),  // C=2
                vec2( 0.50, 0.00),  // D=3
                vec2( 1.00, 0.25),  // E=4
                vec2( 1.00, 0.75)   // F=5
            );

            const uint a_indices[12] = uint[](
                1, 5, 0, // BFA
                1, 4, 5, // BEF
                1, 2, 4, // BCE
                2, 3, 4  // CDE
            );

            void main() {
                const uint i = a_indices[gl_VertexID];

                const uint k = (i + uint(a_instanceAngle60)) % 6;

                v_texCoord = a_texcoord[k];

                v_layer = int(a_instanceLayer);

                const float x = a_position[i].x;

                const float z = a_position[i].y;

                gl_Position = u_projViewMat * a_instanceMat * vec4(x, 0.0, z, 1.0);
            }
            )";

        // Fragment Shader Source
        std::string fs = R"(

                in vec2 v_texCoord;

                flat in int v_layer;

                out vec4 fragColor;

                //uniform sampler2D u_diffuseMap;

                uniform sampler2DArray u_diffuseMapArray;

                // uniform int u_layerIndex;

                void main()
                {
                    // fragColor = texture(u_diffuseMap, v_texCoord);

                    fragColor = texture(u_diffuseMapArray, vec3(v_texCoord, v_layer));
                }
            )";


        std::string const & shaderName = "HexTile";

        m_shader = m_driver->createShader( shaderName, vs, fs );
    }

    // Create textures:
    if (!m_texture2DArray)
    {
        const int w = 256;
        const int h = 256;
        const int layers = 7;
        std::vector<uint8_t> pixels( w * h * layers * 4);

        drawGradient(pixels.data(), w, h, 0,  50,  50, 100, 150, 150, 255); // Water
        drawGradient(pixels.data(), w, h, 1, 255, 255, 200, 255, 255, 150); // Desert
        drawGradient(pixels.data(), w, h, 2, 100, 200, 100,  50, 100,  50); // A
        drawGradient(pixels.data(), w, h, 3, 255, 155, 100, 200, 100, 100); // B
        drawGradient(pixels.data(), w, h, 4, 150, 255, 150, 100, 155, 100); // C
        drawGradient(pixels.data(), w, h, 5, 255, 255, 150, 150, 150,  50); // D
        drawGradient(pixels.data(), w, h, 6, 190, 190, 190,  20,  20,  20); // E

        glGenTextures(1, &m_texture2DArray);
        glBindTexture(GL_TEXTURE_2D_ARRAY, m_texture2DArray);
        glTexImage3D(GL_TEXTURE_2D_ARRAY, 0, GL_RGBA, w, h, layers, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    }

    // Vertex Array Object
    if (!m_vao)
    {
        // Instance Data (Transform Matrices)
        m_instanceMat.clear();
        m_instanceMat.reserve(100);
        m_instanceLayer.clear();
        m_instanceLayer.reserve(100);
        m_instanceAngle60.clear();
        m_instanceAngle60.reserve(100);
        for (int j = 0; j < 10; ++j)
        {
            for (int i = 0; i < 10; ++i)
            {
                const auto x = de::SMeshHexagon::computeBoardPosX(100,100,i,j);
                const auto y = 0.0f;
                const auto z = de::SMeshHexagon::computeBoardPosY(100,100,i,j);
                const auto t = glm::translate(glm::mat4(1.0f), glm::vec3(x, y, z));
                const auto r = glm::mat4(1.0f);
                const auto s = glm::scale(glm::mat4(1.0f), glm::vec3(100.0f));
                auto trs = t * (r * s);
                m_instanceMat.emplace_back( std::move(trs) );

                m_instanceLayer.emplace_back( rand() % 7 );

                m_instanceAngle60.emplace_back( rand() % 6 );
            }
        }

        glGenBuffers(1, &vbo_instanceMat);
        glGenBuffers(1, &vbo_instanceLayer);
        glGenBuffers(1, &vbo_instanceAngle60);
        glGenVertexArrays(1, &m_vao);
        glBindVertexArray(m_vao);

        // vbo_instanceMat:
        glBindBuffer(GL_ARRAY_BUFFER, vbo_instanceMat);
        glBufferData(GL_ARRAY_BUFFER, m_instanceMat.size() * sizeof(glm::mat4), m_instanceMat.data(), GL_STATIC_DRAW);

        // Set up the instance matrix attribute (mat4 spans 4 attribute locations)
        for (int i = 0; i < 4; i++)
        {
            glVertexAttribPointer(i, 4, GL_FLOAT, GL_FALSE, sizeof(glm::mat4), (void*)(sizeof(float) * i * 4));
            glVertexAttribDivisor(i, 1); // Update per instance
            glEnableVertexAttribArray(i);
        }

        // vbo_instanceLayer:
        glBindBuffer(GL_ARRAY_BUFFER, vbo_instanceLayer);
        glBufferData(GL_ARRAY_BUFFER, m_instanceLayer.size() * sizeof(uint8_t), m_instanceLayer.data(), GL_STATIC_DRAW);
        glVertexAttribPointer(4, 1, GL_UNSIGNED_BYTE, GL_FALSE, sizeof(uint8_t), (void*)0);
        glVertexAttribDivisor(4, 1); // Per-instance divisor
        glEnableVertexAttribArray(4);

        // vbo_instanceAngle60:
        glBindBuffer(GL_ARRAY_BUFFER, vbo_instanceAngle60);
        glBufferData(GL_ARRAY_BUFFER, m_instanceAngle60.size() * sizeof(uint8_t), m_instanceAngle60.data(), GL_STATIC_DRAW);
        glVertexAttribPointer(5, 1, GL_UNSIGNED_BYTE, GL_FALSE, sizeof(uint8_t), (void*)0);
        glVertexAttribDivisor(5, 1); // Per-instance divisor
        glEnableVertexAttribArray(5);

        glBindVertexArray(0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
    }
}

// Function to generate gradient textures
void H3_DemoTileRenderer::drawGradient(uint8_t* data, int w, int h, int layer,
                  uint8_t r1, uint8_t g1, uint8_t b1,
                  uint8_t r2, uint8_t g2, uint8_t b2)
{
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            float t = static_cast<float>(y) / (h - 1);
            data[(layer * w * h + y * w + x) * 4 + 0] = r1 * (1 - t) + r2 * t;
            data[(layer * w * h + y * w + x) * 4 + 1] = g1 * (1 - t) + g2 * t;
            data[(layer * w * h + y * w + x) * 4 + 2] = b1 * (1 - t) + b2 * t;
            data[(layer * w * h + y * w + x) * 4 + 3] = 255;
        }
    }
}

void H3_DemoTileRenderer::render( glm::mat4 const & projViewMat )
{
    de::State state;
    state.culling = de::Culling::disabled();
    state.blend = de::Blend::alphaBlend();
    m_driver->setState( state );

    glUseProgram(m_shader->id);

    m_shader->setMat4f( "u_projViewMat", projViewMat );
    //shader->setMat4f( "u_modelMat", modelMat );


    glBindVertexArray(m_vao);
    glDrawArraysInstanced(GL_TRIANGLES, 0, 12, m_instanceMat.size());
}
