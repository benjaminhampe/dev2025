#pragma once
// #include <cstdint>
// #include <sstream>
// #include <vector>
// #include <de/Image.h>
// #include <de/Texture.h>
// #include <de/Math3D_Quaternion.h>

#include <tinyxml2/tinyxml2.h>
// #include <de/GL_debug_layer.h>

#include <de/gpu/GPU.h>
#include <de/gpu/State.h>
#include <iomanip>
#include <fstream>

namespace de {

// ===========================================================================
struct MTL_Light
// ===========================================================================
{
   int typ;
   glm::vec3 siz;   // world size of light source
   glm::vec3 pos;
   glm::vec3 color;
   glm::vec3 dir;
   float maxdist;    // distance
   //float power;      // distance
   //float m_Radius = 500.0f;
   glm::vec3 clipPos; // for Shader, computed by CPU

   //SMeshBuffer mesh;
};

// # =========================================================================
// # 3ds Max Wavefront OBJ Exporter v0.97b - (c)2007 guruware
// # File Created: 10.01.2012 12:09:34
// newmtl 12993_diffuse        // Materialnamen:
//     Ns 30.0000              // Shininess (Glanzgrad):
//     Ni 1.5000               // Optical Density (Brechungsindex):
//     Tr 0.0000 | d 1.0000    // Dissolve (Transparenz):
//     illum 2
//     Ka 1.0000 1.0000 1.0000 // Ambient-Farbe (Umgebungslicht):
//     Kd 1.0000 1.0000 1.0000 // Diffuse-Farbe (Streulicht):
//     Ks 0.3600 0.3600 0.3600 // Specular-Farbe (Spiegellicht):
//     Ke 0.0000 0.0000 0.0000 // Emissive-Farbe (Selbstleuchtung):
//     Tf 1.0000 1.0000 1.0000 //   ?
//     map_Ka fish.jpg         //	map_Ka moon_diffuse.jpg
//     map_Kd fish.jpg         //	map_Kd moon_diffuse.jpg
//     map_bump moon_normal.jpg
//     bump moon_normal.jpg
// ===========================================================================
struct MTL
// ===========================================================================
{
    std::string name; // newmtl Materialname

    glm::vec3 Kd;   // Diffuse-Farbe (Streulicht):
    glm::vec3 Ka;   // Ambient-Farbe (Umgebungslicht):
    glm::vec3 Ks;   // Specular-Farbe (Spiegellicht):
    glm::vec3 Ke;   // Emissive-Farbe (Selbstleuchtung):
    glm::vec3 Tf;   // TransparentColor; // Kt, Tf
    //  Illumination Properties that are turned on in the model Property Editor
    //  0 Color on and Ambient off
    //  1 Color on and Ambient on
    //  2 Highlight on
    //  3 Reflection on and Ray trace on
    //  4 Transparency: Glass on, Reflection: Ray trace on
    //  5 Reflection: Fresnel on and Ray trace on
    //  6 Transparency: Refraction on, Reflection: Fresnel off and Ray trace on
    //  7 Transparency: Refraction on, Reflection: Fresnel on and Ray trace on
    //  8 Reflection on and Ray trace off
    //  9 Transparency: Glass on, Reflection: Ray trace off
    //  10 Casts shadows onto invisible surfaces
    int illum = 2;      // Illumination Model (Beleuchtungsmodell):
    // illum 0: Nur Umgebungslicht.
    //     Beschreibung: Kein Schattierungsmodell.
    //     Lichtkomponenten: Keine.
    //     Verwendung: Nur das Umgebungslicht wird berücksichtigt, und das Material erscheint als durchgehend gleichfarbig.
    // illum 1: Umgebungslicht und Diffuslicht.
    //     Beschreibung: Beleuchtungsmodell mit Umgebungs- und Diffuslicht.
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse).
    //     Verwendung: Einfache Beleuchtung ohne Spiegellicht. Geeignet für Materialien, die nur grundlegende Beleuchtung benötigen.
    // illum 2: Umgebungslicht, Diffuslicht und Spiegelllicht (basierend auf Blinn-Phong-Reflexion).
    //     Beschreibung: Beleuchtungsmodell mit Umgebungs-, Diffus- und Spiegelllicht.
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse), Spiegelllicht (specular).
    //     Verwendung: Blinn-Phong-Reflexion wird verwendet. Geeignet für Materialien, die glänzende Highlights haben.
    // illum 3: Raytracing-Spiegelung (nicht gebräuchlich für Echtzeitrendering).
    //     Beschreibung: Beleuchtungsmodell mit Umgebungs-, Diffus- und Spiegelllicht (auch mit Reflexionen, wenn Texturen verwendet werden).
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse), Spiegelllicht (specular).
    //     Verwendung: Ähnlich wie illum 2, aber auch mit Unterstützung für reflektierende Texturen.
    // illum 4: Raytracing-Spiegelung und Reflektion.
    //     Beschreibung: Raytracing-Spiegelung und Transparenz.
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse), Spiegelllicht (specular), Transparenz (transparency).
    //     Verwendung: Umfasst transparente und spiegelnde Oberflächen. (Nicht Echtzeit-Rendering)
    // illum 5: Umgebungslicht, Diffuslicht, Spiegelllicht und Fresnel-Effekte.
    //     Beschreibung: Beleuchtungsmodell mit Umgebungs-, Diffus- und Spiegelllicht und Fresnel-Effekten.
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse), Spiegelllicht (specular), Fresnel-Effekte.
    //     Verwendung: Spiegellicht wird durch Fresnel-Effekte beeinflusst, um realistischere Reflexionen zu erzeugen.
    // illum 6: Reflektion.
    //     Beschreibung: Beleuchtungsmodell mit Reflektionen.
    //     Lichtkomponenten: Reflektion.
    //     Verwendung: Unterstützt Reflexionen auf der Oberfläche des Materials, aber ohne Transparenz oder Spiegellicht.
    // illum 7: Raytracing-Reflektion und Transparenz (Schattierung mit Durchsichtigkeit).
    //     Beschreibung: Raytracing-Reflektion und Transparenz (Schattierung mit Durchsichtigkeit).
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse), Spiegelllicht (specular), Reflektion, Transparenz.
    //     Verwendung: Umfassendes Modell mit durchscheinenden Reflexionen. (Nicht Echtzeit-Rendering)
    // illum 8: Umgebungslicht, Diffuslicht, Spiegelllicht, Reflektion und Transparenz.
    //     Beschreibung: Beleuchtungsmodell mit Umgebungs-, Diffus- und Spiegelllicht, Reflektion und Transparenz.
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse), Spiegelllicht (specular), Reflektion, Transparenz.
    //     Verwendung: Kombiniert alle Lichtarten und Effekte für realistische Materialdarstellungen.
    // illum 9: Raytracing-Spiegelung, Transparenz und fresnelgebrochene Reflektion.
    //     Beschreibung: Raytracing-Spiegelung, Transparenz und fresnelgebrochene Reflektion.
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse), Spiegelllicht (specular), Reflektion, Transparenz.
    //     Verwendung: Komplexe Reflexionen und Transparenzen mit Fresnel-Effekten. (Nicht Echtzeit-Rendering)
    // illum 10: Raytracing-Transparenz mit Schattenwurf und Fresnel-Effekten.
    //     Beschreibung: Raytracing-Transparenz mit Schattenwurf und Fresnel-Effekten.
    //     Lichtkomponenten: Umgebungslicht (ambient), Diffuslicht (diffuse), Spiegelllicht (specular), Reflektion, Transparenz.
    //     Verwendung: Umfasst fortgeschrittene Transparenz- und Reflexionseffekte mit Schattenwurf. (Nicht Echtzeit-Rendering)
    float Ns = 8.0f;    // Shininess exponent (Glanzgrad):
    float Ni = 1.0f;    // Optical Density (Brechungsindex) | Shininess_strength
    float d = 1.0f;     // Opacity d | Tr factor | Dissolve (Transparenz):
    //float Tr = 0.0f;  // Reflectivity; // Tr

    // BENNI-EXTRA:
    uint32_t materialType = 0; // EMT_SOLID, EMT_TRANSPARENT_VERTEX_ALPHA
    State state;
    Fog fog;
    bool wireframe = false;
    bool cloudTransparent = false;
    // bool gouraudShading;

    // # --- Max.8 Texture Maps: ---
    TexRef map_Kd;      // Diffuse Map: CombiMap: <RGB diffuse color><A transparency/opacity>
    TexRef map_Kn;      // Normal Map: CombiMap: <RGB normal XYZ><A bump elevation>
    TexRef map_bump;    // Bump Map: <map_bump | bump> A = Y
    float Sb = 1.0f;    // Bump Map Scale;
    TexRef map_disp;    // Displacement Map:
    float Sn = 1.0f;    // Normal Map Scale
    TexRef map_detail;  // Detail Map:
    TexRef map_Ks;      // Specular Map:
    TexRef map_Ke;      // Emissive Map:
    TexRef map_Ka;      // Ambient Map:
    TexRef map_d;       // Opacity Map:
    /*


    uint32_t getTextureCount() const;
    bool hasTexture() const;
    TexRef const & getTexture( int stage ) const;
    TexRef & getTexture( int stage );
    void setTexture( int stage, TexRef const & ref );

    std::vector< TexRef > getTextures() const
    {
    std::vector< TexRef > textures;
    if ( !DiffuseMap.empty() ) textures.emplace_back( DiffuseMap );
    if ( !BumpMap.empty() ) textures.emplace_back( BumpMap );
    if ( !NormalMap.empty() ) textures.emplace_back( NormalMap );
    if ( !SpecularMap.empty() ) textures.emplace_back( SpecularMap );
    if ( !DetailMap.empty() ) textures.emplace_back( DetailMap );
    return textures;
    }

//   bool
//   operator==( Material const & o ) const;
//   bool
//   operator!= ( Material const & o ) const { return !( o == *this ); }
//   bool
//   loadMTL( std::string uri, VideoDriver* driver );
//   bool
//   saveMTL( std::string uri ) const;
   bool
   writeXML( tinyxml2::XMLDocument & doc, tinyxml2::XMLElement* matNode ) const;
   bool
   saveXML( std::string uri ) const;
   bool
   loadXML( std::string uri );
*/
    std::string toString() const
    {
        std::ostringstream o;
        o << name << ", ";
/*
        s << "Tex" << getTextureCount() << ", ";
        if ( state.culling.isEnabled() ) { s << state.culling.toString(); }
        if ( Wireframe ){ s << ", W"; }
        if ( FogEnable ){ s << ", F"; }
        //	illum 2
        if ( Lighting > 0) { s << ", illum"<<Lighting; }
        s << ", Ns:" << Shininess;   //	Ns 30.0000
        s << ", Ni:" << Shininess_strength;  //	Ni 1.5000
        s << ", Tr:" << Reflectivity;   //	Tr 0.0000
        if ( hasDiffuseMap() ){ s << ", Td:" << getDiffuseMap().toString(); }
        if ( hasBumpMap() ){ s << ", Tb:" << getBumpMap().toString(); }
        if ( hasNormalMap() ){ s << ", Tn:" << getNormalMap().toString(); }
        if ( hasSpecularMap() ){ s << ", Ts:" << getSpecularMap().toString(); }
        if ( hasDetailMap() ){ s << ", Tdet:" << getDetailMap().toString(); }
        //   { s << ", Ka:" << Ka; }   //	Ka 0.5882 0.5882 0.5882
        //   { s << ", Kd:" << Kd; }   //	Kd 1.0000 1.0000 1.0000
        //   { s << ", Ks:" << Ks; }   //	Ks 0.3600 0.3600 0.3600
        //   { s << ", Ke:" << Ke; }   //	Ke 0.0000 0.0000 0.0000
        //   { s << ", Kt:" << Kt; }
        //	Tf 1.0000 1.0000 1.0000
        //	d 1.0000
*/
        return o.str();
    }
};

// FileReader:    .mtl

// Only makes sense for .obj model files.
// A .mtl stores multiple materials in one file.
// Each Material will result in one meshbuffer?
// Dont know thats why the loader returns a list of SMaterials
// ordered by first encounter in mtl file and by name.

// A list of Material
//   # 3ds
//   # File Created:
//   newmtl 12993_bla_diffuse
//      Ns 30.0000
//      Ni 1.5000
//      d 1.0000
//      Tr 0.0000
//      Tf 1.0000 1.0000 1.0000
//      illum 2
//      Ka 1.0000 1.0000 1.0000
//	     Kd 1.0000 1.0000 1.0000
//	     Ks 0.3600 0.3600 0.3600
//	     Ke 0.0000 0.0000 0.0000
//	     map_Ka fish.jpg
//	     map_Kd fish.jpg

struct MTL_List
{
    // static
    static bool load( std::vector< MTL > & liste, std::string uri )
    {
        //auto fileContent = FileSystem::loadText(uri);

        std::ifstream fin( uri.c_str() );
        if ( !fin.is_open() )
        {
            DE_ERROR("Cannot open file ", uri)
            return false;
        }

        auto isWordChar = [](char c)
        {
            return ((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z')) || (c == '_');
        };

        std::string line;
        size_t numLines = 0;
        while (std::getline(fin,line))
        {
            DE_WARN("[",numLines,"] ",line)
            numLines++;

            line = StringUtil::trimLeft(line, " ");

            size_t i = 0;
            int parseWord = 0;
            int foundWords = 0;
            size_t p1 = 0;
            size_t p2 = 0;
            std::string firstWord;

            for (size_t i = 0; i < line.size(); i++)
            {
                char c = line[i];
                if (c == '#')
                {
                    break; // Stop parsing line
                }

                if (foundWords == 0)
                {

                if (parseWord == 0)
                {
                    if (isWordChar(c))
                    {
                        p1 = i;
                        parseWord = 1;
                    }
                }
                else // if (parseWord == 1)
                {
                    if (!isWordChar(c))
                    {
                        p2 = i;
                        parseWord = 0;
                        firstWord = line.substr(p1,p2-p1);
                        foundWords = 1;
                        DE_DEBUG("Found Command ", firstWord)
                    }
                }

                }
                else
                {

                }
            }
        }

        return true;
    }

    // static
    static bool save( std::vector< MTL > const & liste, std::string uri )
    {
        DE_DEBUG("Write ",liste.size()," materials as MTL" )
        std::ostringstream s;

        auto write_int = [&] ( std::string name, int value )
        {
            s << "   " << name << " " << value << "\n";
        };

        auto write_float = [&] ( std::string name, float value )
        {
            std::setprecision( 4 );
            s << "   " << name << " " << value << "\n";
        };

        auto write_float_rgb = [&] ( std::string name, glm::vec3 const & color )
        {
            std::setprecision( 4 );
            s << "   " << name << " "
              << color.r << " "
              << color.g << " "
              << color.b << "\n";
        };

        auto write_tex = [&] ( std::string name, std::string tex )
        {
            if ( tex.empty() ) return;

            std::string uri = tex;
            StringUtil::lowerCase( uri );

            if ( StringUtil::endsWith( tex, "") )
            {

            }
            s << "   " << name << " " << tex << "\n";
        };

        //s << "# exported by libDarkGPU (c) Benjamin Hampe 2021\n"
        for ( size_t i = 0; i < liste.size(); ++i )
        {
            MTL const & mtl = liste[ i ];
            s << "newmtl " << mtl.name << "\n";
            write_float( "Ns", mtl.Ns ); // shininess / 0.128f;
            write_float( "Ni", mtl.Ni );
            write_float( "d", mtl.d );    // float ?
            //write_float( "Tr", mtl.Reflectivity );   // float ?
            write_float_rgb( "Tf", glm::vec3(1,1,1) );   // vec3 ?
            write_int( "illum", mtl.illum );

            write_float_rgb( "Ka", mtl.Ka );
            write_float_rgb( "Kd", mtl.Kd );
            write_float_rgb( "Ks", mtl.Ks );
            write_float_rgb( "Ke", mtl.Ke );
            //write_float_rgb( "Kr", mtl.Kr );
            //write_float_rgb( "Kt", mtl.Kt );

            if ( !mtl.map_Kd.name.empty() )
            {
                write_tex( "map_Kd", mtl.map_Kd.name );
            }
            if ( !mtl.map_bump.name.empty() )
            {
                write_tex( "map_bump", mtl.map_bump.name );
            }
            if ( !mtl.map_Kn.name.empty() )
            {
                write_tex( "map_Kn", mtl.map_Kn.name );
            }
            if ( !mtl.map_Ks.name.empty() )
            {
                write_tex( "map_Ks", mtl.map_Ks.name );
            }
            s << "\n";
        }

        return FileSystem::saveText( uri, s.str() );
    }


};
/*
newmtl name         // Materialnamen:
# --- Colors: ---
    Ka r g b        // Ambient-Farbe (Umgebungslicht):
    Kd r g b        // Diffuse-Farbe (Streulicht):
    Ks r g b        // Specular-Farbe (Spiegellicht):
    Ke r g b        // Emissive-Farbe (Selbstleuchtung):
# --- Constants: ---
    Ns exponent     // Shininess (Glanzgrad):
    Ni 1.0          // Optical Density (Brechungsindex):
    d | Tr factor   // Dissolve (Transparenz):
    illum           // Illumination Model (Beleuchtungsmodell):
# --- Texture Maps: ---
    map_Ka uri  // Ambient Map:
    map_Kd uri  // Diffuse Map:
    map_Ks uri  // Specular Map:
    map_Ke uri  // Emissive Map:
    map_bump uri // Bump Map:
    disp uri    // Displacement Map:
    map_d uri   // Opacity Map:


C++:

float positions[] = {
    0.5f,  0.5f, 0.0f,  // Oben rechts
    0.5f, -0.5f, 0.0f,  // Unten rechts
    -0.5f, -0.5f, 0.0f, // Unten links
    -0.5f,  0.5f, 0.0f  // Oben links
};

float colors[] = {
    1.0f, 0.0f, 0.0f,  // Rot
    0.0f, 1.0f, 0.0f,  // Grün
    0.0f, 0.0f, 1.0f,  // Blau
    1.0f, 1.0f, 0.0f   // Gelb
};

GLuint vao, vboPositions, vboColors;
glGenVertexArrays(1, &vao);
glGenBuffers(1, &vboPositions);
glGenBuffers(1, &vboColors);

glBindVertexArray(vao);

// Position VBO
glBindBuffer(GL_ARRAY_BUFFER, vboPositions);
glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

// Farbe VBO
glBindBuffer(GL_ARRAY_BUFFER, vboColors);
glBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(1);

glBindVertexArray(0);


GLint ambientLoc = glGetUniformLocation(shaderProgram, "material.ambient");
GLint diffuseLoc = glGetUniformLocation(shaderProgram, "material.diffuse");
GLint specularLoc = glGetUniformLocation(shaderProgram, "material.specular");
GLint shininessLoc = glGetUniformLocation(shaderProgram, "material.shininess");

glUniform3f(ambientLoc, 1.0f, 0.5f, 0.31f);  // Beispielwerte
glUniform3f(diffuseLoc, 1.0f, 0.5f, 0.31f);
glUniform3f(specularLoc, 0.5f, 0.5f, 0.5f);
glUniform1f(shininessLoc, 32.0f);



VS:

#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoord;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoord = aTexCoord;

    gl_Position = projection * view * vec4(FragPos, 1.0);
}

FS:

#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoord;

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
    sampler2D ambientMap;
    sampler2D diffuseMap;
    sampler2D specularMap;
    sampler2D bumpMap;
};

struct Light {
    vec3 position;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

uniform Material material;
uniform Light light;
uniform vec3 viewPos;
uniform int illum;

void main()
{
    vec3 ambientColor = material.ambient * light.ambient;
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(light.position - FragPos);
    vec3 viewDir = normalize(viewPos - FragPos);

    // Bump Mapping
    vec3 bumpNormal = texture(material.bumpMap, TexCoord).rgb;
    bumpNormal = bumpNormal * 2.0 - 1.0; // convert from [0,1] range to [-1,1] range
    normal = normalize(normal + bumpNormal);

    // Diffuse shading
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuseColor = material.diffuse * light.diffuse * diff;

    // Specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    vec3 specularColor = material.specular * light.specular * spec;

    // Combine all three components
    vec3 result;
    if(illum == 2) // Only ambient and diffuse
    {
        result = ambientColor + diffuseColor;
    }
    else if(illum == 3) // Ambient, diffuse, and specular
    {
        result = ambientColor + diffuseColor + specularColor;
    }
    else
    {
        result = vec3(0.0); // Default to black if unsupported illum model
    }

    FragColor = vec4(result, 1.0);
}


*/
// ===========================================================================
// Material = State + Textures + Fog + Transparenz + Lighting = TnL 1-4 textures
// ===========================================================================

} // end namespace de.
