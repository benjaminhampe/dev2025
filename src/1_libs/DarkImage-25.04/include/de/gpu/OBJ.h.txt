dw#pragma once
// #include <cstdint>
// #include <sstream>
// #include <vector>
#include <de/gpu/MTL.h>
// #include <de/Image.h>
// #include <de/Texture.h>
// #include <de/Math3D_Quaternion.h>
// #include <tinyxml2/tinyxml2.h>
// #include <de/GL_debug_layer.h>

namespace de {

/*
   virtual uint32_t countTriangles() const
   {
      if ( getIndexCount() > 0 )
      {
         switch( getPrimitiveType() )
         {
            case PrimitiveType::Triangles: return getIndexCount() / 3;     // #num triangles in Triangles
            case PrimitiveType::TriangleStrip: return getIndexCount() - 2; // #num triangles in Strip
            case PrimitiveType::TriangleFan: return getIndexCount() - 2;   // #num triangles in Fan
            case PrimitiveType::Quads: return 2*(getIndexCount() / 4);         // #num quads in Quads
            default: return 0;
         }
      }
      else
      {
         switch( getPrimitiveType() )
         {
            case PrimitiveType::Triangles: return getVertexCount() / 3;     // #num triangles in Triangles
            case PrimitiveType::TriangleStrip: return getVertexCount() - 2; // #num triangles in Strip
            case PrimitiveType::TriangleFan: return getVertexCount() - 2;   // #num triangles in Fan
            case PrimitiveType::Quads: return 2*(getVertexCount() / 4);     // #quads = #v / 4, #tris = 2 / quad.
            default: return 0;
         }
      }
   }
*/

#pragma pack( push )
#pragma pack( 1 )

// ===========================================================================
struct OBJ_Vertex // 4*12 + 4 + 2*8 = 48 + 4 + 8 = 60 Bytes if packed
// ===========================================================================
{
   glm::vec3 pos;
   glm::vec3 normal;
   glm::vec3 tangent;
   glm::vec3 bitangent;
   uint32_t color;
   glm::vec2 tex;
   //glm::vec2 tex2;

   OBJ_Vertex()
      : pos(), normal(0,1,0), tangent(1,0,0), bitangent(0,0,1), color( 0xFFFF00FF ), tex()
   {}
   OBJ_Vertex( float x, float y, float z, float nx, float ny, float nz, uint32_t crgba, float u, float v )
      : pos( x,y,z ), normal( nx,ny,nz ), tangent(1,0,0), bitangent(0,0,1), color( crgba ), tex( u,v )
   {}
   OBJ_Vertex( glm::vec3 const & p, glm::vec3 const & nrm, uint32_t crgba, glm::vec2 const & tex0 )
      : pos( p ), normal( nrm ), tangent(1,0,0), bitangent(0,0,1), color( crgba ), tex( tex0 )
   {}

   void flipV()
   {
      tex.y = glm::clamp( 1.0f - tex.y, 0.f, 1.0f ); // Invert v for OpenGL
   }
};

#pragma pack( pop )

// ===========================================================================
struct OBJ
// =======================================================================
{
    PrimitiveType PrimType = PrimitiveType::Points;
    uint32_t VAO = 0;
    uint32_t VBO = 0;
    uint32_t IBO = 0;
    Box3f BoundingBox;
    glm::dmat4 ModelMat = glm::dmat4(1.0);
    MTL Material;
    std::vector< OBJ_Vertex > Vertices;
    std::vector< uint32_t > Indices;

    std::vector< glm::vec3 > computePoints() const
    {
        std::vector< glm::vec3 > container;
        container.reserve( Vertices.size() );
        for ( const auto& v : Vertices ) { container.emplace_back( v.pos ); }
        return container;
    }

    size_t computeMemorySizeInBytes() const
    {
        size_t n = sizeof( *this );
        n += Vertices.capacity() * sizeof( OBJ_Vertex );
        n += Indices.capacity() * sizeof( uint32_t );
        return n;
    }

    std::string toString( bool withFVF = false ) const
    {
        const auto dx = int32_t( BoundingBox.getSize().x );
        const auto dy = int32_t( BoundingBox.getSize().y );
        const auto dz = int32_t( BoundingBox.getSize().z );
        std::stringstream o; o <<
        "p(" << PrimType.toString() << "), "
        "v(" << Vertices.size() << "), "
        "i(" << Indices.size() << "), "
        "bbox(" << dx << "," << dy << "," << dz << "), "
        "mat(" << Material.toString() << ")";
        return o.str();
    }

    void recalculateBoundingBox()
    {
        if ( Vertices.empty() )
        {
            BoundingBox.reset();
        }
        else
        {
            BoundingBox.reset( Vertices[ 0 ].pos );
            for ( size_t i = 1; i < Vertices.size(); ++i )
            {
                BoundingBox.addInternalPoint( Vertices[ i ].pos );
            }
        }
    }

    void rotate( glm::vec3 new_nrm, glm::vec3 old_nrm = glm::vec3(0.0f,0.0f,-1.0f) )
    {
        if ( old_nrm == new_nrm )
        {
            return;
        }
        recalculateBoundingBox();
        auto bb = BoundingBox;
        auto cc = bb.getCenter();
        auto qq = Quatf::from2Vectors( old_nrm, new_nrm );
        for ( size_t i = 0; i < Vertices.size(); ++i )
        {
            auto v1 = Vertices[ i ].pos - cc; // dir from center to pos
            auto l1 = glm::length( v1 ); // length
            auto v2 = qq.rotate( v1 ); // rotated dir with length one.
            auto p2 = cc + v2 * l1; // pos = center + rotated dir with length len1.
            Vertices[ i ].pos = p2;
        }
    }

/*
   std::vector< Triangle3f >
   createCollisionTriangles() const
   {
      if ( PrimType != PrimitiveType::Triangles ) return {};

      std::vector< Triangle3f > tris;

      if ( Indices.size() > 0 )
      {
         tris.reserve( tris.size() + Indices.size()/3 );
         for ( size_t i = 0; i < Indices.size()/3; ++i )
         {
            tris.emplace_back( getPos( Indices[ 3*i   ] ),
                               getPos( Indices[ 3*i+1 ] ),
                               getPos( Indices[ 3*i+2 ] ));
         }
      }
      else
      {
         tris.reserve( tris.size() + getVertexCount()/3 );
         for ( size_t i = 0; i < getVertexCount()/3; ++i )
         {
            tris.emplace_back( getPos( 3*i ),
                               getPos( 3*i+1 ),
                               getPos( 3*i+2 ) );
         }
      }

      return tris;
   }

   virtual void
   forAllTriangles( std::function< void(uint32_t, Triangle3f const &)> const & func ) const
   {
      // [Triangles]
      if ( getPrimitiveType() == PrimitiveType::Triangles )
      {
         if ( getVertexCount() < 3 )
         {
            return; // no triangles
         }

         if ( getIndexCount() > 0 )
         {
            if ( getIndexCount() < 3 ) { return; }
            for ( size_t i = 0; i < getIndexCount()/3; i++ )
            {
               auto const & a = getPos( getIndex( 3*i ) );
               auto const & b = getPos( getIndex( 3*i+1 ) );
               auto const & c = getPos( getIndex( 3*i+2 ) );
               func( i, Triangle3f(a,b,c) );
            }
         }
         else
         {
            for ( size_t i = 0; i < getVertexCount()/3; i++ )
            {
               auto const & a = getPos( 3*i );
               auto const & b = getPos( 3*i+1 );
               auto const & c = getPos( 3*i+2 );
               func( i, Triangle3f(a,b,c) );
            }
         }
      }

      // [TriangleStrip]
      else if ( getPrimitiveType() == PrimitiveType::TriangleStrip )
      {
         if ( getVertexCount() < 3 )
         {
            return; // no triangle strip
         }

         if ( getIndexCount() > 0 )
         {
            if ( getVertexCount() < 3 ) { return; }
            if ( getIndexCount() < 3 ) { return; }

            for ( size_t i = 2; i < getIndexCount(); i++ )
            {
               auto const & a = getPos( getIndex( i-2 ) );
               auto const & b = getPos( getIndex( i-1 ) );
               auto const & c = getPos( getIndex( i ) );
               func( i-2, Triangle3f(a,b,c) );
            }
         }
         else
         {
            if ( getVertexCount() < 3 ) { return; }

            for ( size_t i = 2; i < getVertexCount(); i++ )
            {
               auto const & a = getPos( i-2 );
               auto const & b = getPos( i-1 );
               auto const & c = getPos( i );
               func( i-2, Triangle3f(a,b,c) );
            }
         }
      }

      // [BenniQuads]
      else if ( getPrimitiveType() == PrimitiveType::Quads )
      {
         if ( getVertexCount() < 4 )
         {
            return; // no quads
         }

         if ( getIndexCount() > 0 )
         {
            for ( size_t i = 0; i < getIndexCount()/4; i++ )
            {
               auto const & a = getPos( getIndex( 4*i ) );
               auto const & b = getPos( getIndex( 4*i+1 ) );
               auto const & c = getPos( getIndex( 4*i+2 ) );
               auto const & d = getPos( getIndex( 4*i+3 ) );
               // process quad, aka 2 triangles from 4 indexed vertices
               func( 2*i, Triangle3f(a,b,c) );
               func( 2*i+1, Triangle3f(a,c,d) );
            }
         }
         else
         {
            for ( size_t i = 0; i < getVertexCount()/4; i++ )
            {
               auto const & a = getPos( 4*i );
               auto const & b = getPos( 4*i+1 );
               auto const & c = getPos( 4*i+2 );
               auto const & d = getPos( 4*i+3 );
               // process quad, aka 2 triangles from 4 indexed vertices
               func( 2*i, Triangle3f(a,b,c) );
               func( 2*i+1, Triangle3f(a,c,d) );
            }
         }

      }
      else
      {
         DE_ERROR("Unsupported PrimType = ", getPrimitiveTypeStr())
      }
   }

   template < typename T >
   bool
   intersectRayWithBoundingBox( Ray3< T > const & ray, MeshIntersectionResult< T > & result ) const
   {
      Box3< T >         bbox( BoundingBox.getMin(), BoundingBox.getMax() );
      T                 beginDist = std::numeric_limits< T >::max();
      T                 globalHitDist = beginDist;
      glm::tvec3< T >   globalHitPos;
      Triangle3< T >    globalTriangle;
      int32_t           globalTriangleIndex = -1;
      bool              doesIntersect = false;

      for ( size_t i = 0; i < 12; ++i ) // Loop 12 bbox triangles
      {
         glm::tvec3< T > localHitPos; // local

         Triangle3< T > const & localTriangle = bbox.getTriangle( i );

         if ( localTriangle.intersectRay( ray.getPos(), ray.getDir(), localHitPos ) )
         {
            auto localHitDist = glm::length( ray.getPos() - localHitPos );
            if ( localHitDist == beginDist || globalHitDist > localHitDist )
            {
               doesIntersect = true;
               globalHitDist = localHitDist;
               globalHitPos = localHitPos;
               globalTriangle = localTriangle;
               globalTriangleIndex = i;
            }
         }
         //DE_DEBUG("Mesh[",i,"].Triangle[", t, "] = ", tri.toString() )
      }

      if ( doesIntersect )
      {
         result.meshIndex = -1;     // indicates bbox
         result.bufferIndex = -1;   // indicates bbox
         result.triangle = globalTriangle;
         result.triangleIndex = globalTriangleIndex; // triangle of bbox 0..11
         result.distance = globalHitDist;
         result.position = globalHitPos;
      }
      return doesIntersect;
   }

   template < typename T >
   bool
   intersectRay( Ray3< T > const & ray, MeshIntersectionResult< T > & result ) const
   {
      if ( !intersectRayWithBoundingBox( ray, result ) )
      {
         return false;
      }

      T const distMax = std::numeric_limits< T >::max();
      T globalHitDistance = distMax;
      glm::tvec3< T > globalHitPosition;
      uint32_t globalTriangleIndex = 0;
      Triangle3< T > globalTriangle;
      bool doesIntersect = false;

      forAllTriangles(
         [&] ( uint32_t triIndex, Triangle3< T > const & triangle )
         {
            glm::tvec3< T > tmpPos;
            if ( triangle.intersectRay( ray.getPos(), ray.getDir(), tmpPos ) )
            {
               doesIntersect = true;
               auto localDistance = glm::length( ray.getPos() - tmpPos );
               if ( globalHitDistance == distMax || globalHitDistance >= localDistance )
               {
                  globalTriangle = triangle;
                  globalHitDistance = localDistance;
                  globalHitPosition = tmpPos;
                  globalTriangleIndex = triIndex;
               }
            }
         }
      );

      if ( doesIntersect )
      {
         result.meshIndex = -1;     // indicates bbox
         result.bufferIndex = -1;   // indicates bbox
         result.triangle = globalTriangle;
         result.triangleIndex = globalTriangleIndex; // triangle of bbox 0..11
         result.distance = globalHitDistance;
         result.position = globalHitPosition;
      }
      return doesIntersect;
   }

   void addVertex( TVertex const & vertex )
   {
//      if ( m_vertices.empty() )
//      {
//         BoundingBox.reset( glm::vec3(vertex.pos) );
//      }
//      else
//      {
//         BoundingBox.addInternalPoint( glm::vec3(vertex.pos) );
//      }

      m_vertices.push_back( vertex );
   }

   void addLine( TVertex const & a, TVertex const & b )
   {
      auto v = getVertexCount();
      addVertex( a );
      addVertex( b );
      addIndex( v );
      addIndex( v+1 );
   }

//   void
//   addTriangle( TVertex const & a, TVertex const & b, TVertex const & c )
//   {
//      addVertex( a );
//      addVertex( b );
//      addVertex( c );
//      addIndexedTriangle();
//   }

   void
   addLineTriangle( TVertex const & a, TVertex const & b, TVertex const & c )
   {
      auto v = getVertexCount();
      addVertex( a );
      addVertex( b );
      addVertex( c );
      addIndexedLine( v, v+1 );
      addIndexedLine( v+1, v+2 );
      addIndexedLine( v+2, v );
   }

   void
   addLineQuad( TVertex const & a, TVertex const & b, TVertex const & c, TVertex const & d )
   {
      auto v = getVertexCount();
      addVertex( a );
      addVertex( b );
      addVertex( c );
      addVertex( d );
      addIndexedLine( v, v+1 );
      addIndexedLine( v+1, v+2 );
      addIndexedLine( v+2, v+3 );
      addIndexedLine( v+3, v );
   }


   void
   addIndex()
   {
      //assert( size_t( index ) <= size_t( std::numeric_limits< TIndex >::max() ) );
      if ( m_vertices.empty() )
      {
         //DE_ERROR("No Vertices")
         return;
      }
      m_indices.push_back( m_vertices.size() - 1 );
   }

   void
   addIndex( uint32_t index ) override
   {
      //assert( size_t( index ) <= size_t( std::numeric_limits< TIndex >::max() ) );
      m_indices.push_back( index );
   }

   void
   addTriangle( TVertex const & a, TVertex const & b, TVertex const & c, bool flip = false )
   {
      size_t const v = getVertexCount();
      if ( flip )
      {
         addVertex( a );
         addVertex( c );
         addVertex( b );
      }
      else
      {
         addVertex( a );
         addVertex( b );
         addVertex( c );
      }

      addIndex( v );
      addIndex( v+1 );
      addIndex( v+2 );
   }

   void
   addQuad( TVertex const & a, TVertex const & b, TVertex const & c, TVertex const & d, bool flip = false )
   {
      addVertex( a );
      addVertex( b );
      addVertex( c );
      addVertex( d );
      addIndexedQuad( flip );
   }

   void
   addVertexQuad( TVertex const & a, TVertex const & b, TVertex const & c, TVertex const & d, bool flip = false )
   {
      if ( flip )
      {
         addVertex( a );
         addVertex( c );
         addVertex( b );
         addVertex( a );
         addVertex( d );
         addVertex( c );
      }
      else
      {
         addVertex( a );
         addVertex( b );
         addVertex( c );
         addVertex( a );
         addVertex( c );
         addVertex( d );
      }
   }

   void
   addIndexedTriangle( uint32_t a, uint32_t b, uint32_t c, bool flip = false )
   {
      if ( flip )
      {
         addIndex( a );
         addIndex( c );
         addIndex( b );
      }
      else
      {
         addIndex( a );
         addIndex( b );
         addIndex( c );
      }
   }

   void
   addIndexedTriangle( bool flip = false )
   {
      uint32_t const v = getVertexCount();
      if ( v < 3 ) return;
      addIndexedTriangle( v-3, v-2, v-1, flip );
   }

   // Quad ABCD: (ccw) ACB + ADC, (cw) ABC + ACD
   void
   addIndexedQuad( uint32_t a, uint32_t b, uint32_t c, uint32_t d, bool flip = false )
   {
      addIndexedTriangle( a,b,c, flip );
      addIndexedTriangle( a,c,d, flip );
      //addIndex( a ); addIndex( c ); addIndex( b );
      //addIndex( a ); addIndex( d ); addIndex( c );
   }

   void
   addIndexedQuad( bool flip = false )
   {
      uint32_t const v = getVertexCount();
      if ( v < 4 ) return;
      addIndexedQuad( v-4, v-3, v-2, v-1, flip );
   }

   void
   addIndexedLine( uint32_t a, uint32_t b )
   {
      addIndex( a );
      addIndex( b );
   }

   void
   addIndexedLine()
   {
      uint32_t const v = getVertexCount();
      if ( v < 2 ) return;
      addIndex( v-2 );
      addIndex( v-1 );
   }

   void
   addIndexedLineTriangle( uint32_t a, uint32_t b, uint32_t c )
   {
      addIndex( a ); addIndex( b );
      addIndex( b ); addIndex( c );
      addIndex( c ); addIndex( a );
   }

   void
   addIndexedLineQuad( uint32_t a, uint32_t b, uint32_t c, uint32_t d )
   {
      addIndex( a ); addIndex( b );
      addIndex( b ); addIndex( c );
      addIndex( c ); addIndex( d );
      addIndex( d ); addIndex( a );
   }

   void
   addIndexedLineBox( uint32_t a, uint32_t b, uint32_t c, uint32_t d,
                    uint32_t e, uint32_t f, uint32_t g, uint32_t h )
   {
      addIndexedLineQuad( a, b, c, d );
      addIndexedLineQuad( e, f, g, h );
      addIndexedLine( a, e );
      addIndexedLine( b, f );
      addIndexedLine( c, g );
      addIndexedLine( d, h );
   }


   void
   addIndexedLineTriangle()
   {
      uint32_t const v = getVertexCount();
      if ( v < 3 ) return;
      addIndexedLineTriangle( v-3, v-2, v-1 );
   }

   void
   addIndexedLineQuad()
   {
      uint32_t const v = getVertexCount();
      if ( v < 4 ) return;
      addIndexedLineQuad( v-4, v-3, v-2, v-1 );
   }
*/

};

#if 0

// =======================================================================
template < typename T > struct MeshIntersectionResult
// =======================================================================
{
   glm::tvec3< T > position;
   T distance = T(0);
   Triangle3< T > triangle;
   int32_t triangleIndex = -1;
   int32_t bufferIndex = -1;
   int32_t meshIndex = -1;
   int32_t nodeIndex = -1;
};



// ===========================================================================
struct SMeshBufferTool
// ===========================================================================
{
    DE_CREATE_LOGGER("de.gpu.SMeshBufferTool")

    static void
    transformPoints( std::vector< glm::vec3 > & points, glm::dmat4 const & modelMat );
    static void
    rotatePoints( std::vector< glm::vec3 > & points, float a, float b, float c );
    static void
    rotateTexCoords90_onlyQuads( SMeshBuffer & mesh );
    static SMeshBuffer
    tesselate( SMeshBuffer const & src );
    static void
    fuse( SMeshBuffer & dst, SMeshBuffer const & src, glm::vec3 const & offset = glm::vec3() );
    static void
    fuse( SMeshBuffer & dst, std::vector< SMeshBuffer > const & meshes );
    static uint32_t
    countVertices( std::vector< SMeshBuffer > const & liste );
    static uint32_t
    countIndices( std::vector< SMeshBuffer > const & liste );
    static std::vector< Triangle3f >
    createCollisionTriangles( SMeshBuffer const & b );
    static void
    computeBoundingBox( SMeshBuffer & o );
    static Box3f
    computeBoundingBox( std::vector< S3DVertex > const & vertices );
    static void
    computeNormals( SMeshBuffer & o );
    static void
    computeNormals( std::vector< S3DVertex > & vertices, std::vector< uint32_t > const & indices );
    static void
    bumpVertices( SMeshBuffer & o, Image* bumpMap, float bumpScale = 1.0f );

    static void
    flipX( SMeshBuffer & o );
    static void
    flipY( SMeshBuffer & o );
    static void
    flipZ( SMeshBuffer & o );
    static void
    flipXY( SMeshBuffer & o );
    static void
    flipYZ( SMeshBuffer & o );
    static void
    flipXZ( SMeshBuffer & o );
    static void
    flipNormals( SMeshBuffer & o );
    static void
    flipVertexPosYZ( SMeshBuffer & o );
    static void
    flipWinding( SMeshBuffer & o );

    static void
    translateVertices( SMeshBuffer & o, glm::vec3 const & offset );
    static void
    translateVertices( SMeshBuffer & o, glm::vec3 const & offset, uint32_t vStart );
    static void
    translateVertices( SMeshBuffer & o, float x, float y, float z );
    static void
    transformVertices( SMeshBuffer & o, glm::dmat4 const & modelMat = glm::dmat4(1.0) );

    static void
    randomRadialDisplace( SMeshBuffer & o, float h );

    static void
    rotateVertices( SMeshBuffer & o, float a, float b, float c );
    static void
    scaleVertices( SMeshBuffer & o, float scale = 1.01f );
    static void
    scaleVertices( SMeshBuffer & o, float sx, float sy, float sz );

    static void
    translateNormals( SMeshBuffer & o, glm::vec3 const & offset );
    static void
    translateNormals( SMeshBuffer & o, float nx, float ny, float nz );
    static void
    setNormals( SMeshBuffer & o, glm::vec3 const & normal );
    static void
    setNormals( SMeshBuffer & o, float nx, float ny, float nz );
    static void
    setNormalZ( SMeshBuffer & o, float nz );

    static void
    scaleTexture( SMeshBuffer & o, float u, float v );
    static void
    transformTexCoords( SMeshBuffer & o, Recti const & r_atlas, int atlas_w, int atlas_h );
    static void
    colorVertices( SMeshBuffer & o, uint32_t color );
    static void
    centerVertices( SMeshBuffer & o );
    /*
   static SMeshBuffer
   createLines();

   static SMeshBuffer
   createTriangles();
*/
    static void
    addVertex( SMeshBuffer & o, S3DVertex const & vertex );
    static void
    addVertex( SMeshBuffer & o, glm::vec3 const & pos, glm::vec3 const & nrm, uint32_t color, glm::vec2 const & tex );
    static void
    addVertex( SMeshBuffer & o, glm::vec3 const & pos, uint32_t color );
    static void
    addLine( SMeshBuffer & o, S3DVertex const & a, S3DVertex const & b );
    static void
    addTriangle( SMeshBuffer & o, S3DVertex const & a, S3DVertex const & b, S3DVertex const & c );
    static void
    addLine( SMeshBuffer & o, glm::vec3 const & a, glm::vec3 const & b, uint32_t color = 0xFFFFFFFF );
    static void
    addLine( SMeshBuffer & o, glm::vec3 const & a, glm::vec3 const & b, uint32_t colorA, uint32_t colorB );
    static void
    addLine( SMeshBuffer & o, float x1, float y1, float x2, float y2, float z = 0.0f, uint32_t color = 0xFFFFFFFF );
    static void
    addLine( SMeshBuffer & o, float x1, float y1, float x2, float y2, float z, uint32_t colorA, uint32_t colorB );
    static void
    addLineTriangle( SMeshBuffer & o, glm::vec3 const & a, glm::vec3 const & b, glm::vec3 const & c, uint32_t color = 0xFFFFFFFF );
    static void
    addLineTriangle( SMeshBuffer & o, glm::vec3 const & a, glm::vec3 const & b, glm::vec3 const & c, uint32_t colorA, uint32_t colorB, uint32_t colorC );
    static void
    addLineQuad( SMeshBuffer & o, glm::vec3 const & a, glm::vec3 const & b, glm::vec3 const & c, glm::vec3 const & d, uint32_t color = 0xFFFFFFFF );
    static void
    addLineQuad( SMeshBuffer & o, glm::vec3 const & a, glm::vec3 const & b, glm::vec3 const & c, glm::vec3 const & d,
                uint32_t colorA, uint32_t colorB, uint32_t colorC = 0xFFFFFFFF, uint32_t colorD = 0xFFFFFFFF );
    static void
    addLineBox( SMeshBuffer & o, Box3f const & box, uint32_t color );

    // =======================================================================
    // DebugGeometry:
    // =======================================================================
    static void
    addLineNormals( SMeshBuffer & o, SMeshBuffer const & src, float n_len, uint32_t color );
    static void
    addWireframe( SMeshBuffer & o, SMeshBuffer const & src, float outScale, uint32_t color );
    static SMeshBuffer
    createWireframe( SMeshBuffer const & src, float scale = 1.0f, uint32_t color = 0 );
    static SMeshBuffer
    createScaled( SMeshBuffer const & src, float scale = 1.01f );
    static SMeshBuffer
    createTranslated( SMeshBuffer const & src, glm::vec3 pos );
    static SMeshBuffer
    createLineBox( Box3f const & box, uint32_t color );
    static SMeshBuffer
    createLineNormals( SMeshBuffer const & src, float normalLen, uint32_t color );
};

// ===========================================================================
struct IMesh
// ===========================================================================
{
   virtual ~IMesh() = default;
   virtual void clear() = 0;
   virtual void upload() = 0;
   virtual glm::dmat4 const & getModelMatrix() const = 0;
   virtual void setModelMatrix( glm::dmat4 const & modelMat ) = 0;
   virtual std::string getName() const = 0;
   virtual void setName( std::string const & name ) = 0;
   virtual bool isVisible() const = 0;
   virtual void setVisible( bool visible ) = 0;
   virtual Box3f const & getBoundingBox() const = 0;
   virtual void setBoundingBox( Box3f const & box ) = 0;
   virtual int getMaterialCount() const = 0;
   virtual SMaterial const & getMaterial( int i ) const = 0;
   virtual SMaterial & getMaterial( int i ) = 0;
   virtual std::string getPrimTypesStr() const = 0;
};



// ===========================================================================
struct SMesh : public IMesh
// ===========================================================================
{
   typedef double T;
   typedef std::shared_ptr< SMesh > SharedPtr;
   typedef std::unique_ptr< SMesh > UniquePtr;
   typedef std::weak_ptr< SMesh > WeakPtr;

   static SharedPtr
   createShared( std::string const & name = "" ) { return std::make_shared< SMesh >(); }

   static SharedPtr
   createShared( SMeshBuffer const & buf ) { return std::make_shared< SMesh >( buf ); }

   SMesh();
   SMesh( char const* name );
   SMesh( std::string const & name );
   SMesh( SMeshBuffer const & buf );

   std::vector<ITexture*> getUniqueTextures() const;
   std::string       getPrimTypesStr() const override;

   void              upload() override;
   void              clear() override;

   glm::dmat4 const& getModelMatrix() const override { return ModelMat; }
   void              setModelMatrix( glm::dmat4 const & modelMat ) override { ModelMat = modelMat; }

   std::string       getName() const override { return Name; }
   void              setName( std::string const & name ) override { Name = name; }

   bool              isVisible() const override { return Visible; }
   void              setVisible( bool visible ) override { Visible = visible; }

   Box3f const &     getBoundingBox() const override { return BoundingBox; }
   void              setBoundingBox( Box3f const & bbox ) override { BoundingBox = bbox; }

   int               getMaterialCount() const override;
   SMaterial const & getMaterial( int i ) const override;
   SMaterial &       getMaterial( int i ) override;

   void              addEmptyBuffer();
   void              addMeshBuffer( SMeshBuffer const & buf );
   void              addMesh( SMesh const & other );

   std::vector< SMeshBuffer > const &  getMeshBuffers() const { return Buffers; }
   std::vector< SMeshBuffer > &        getMeshBuffers() { return Buffers; }

   int               getMeshBufferCount() const;
   SMeshBuffer const& getMeshBuffer( int i ) const;
   SMeshBuffer&      getMeshBuffer( int i );

   void              removeMeshBuffer( int i );
   //void            shiftMeshBuffer( int shifts );
   void              recalculateNormals();
   void              recalculateBoundingBox( bool fully = false );
   bool              isIndex( int i ) const;

   std::string       toString( bool printDetails = false ) const;
   size_t            getVertexCount() const;
   size_t            getIndexCount() const;
   size_t            computeMemoryConsumption() const;

   int               getLighting() const;
   int               getFogEnable() const;
   int               getWireframe() const;

   void setLighting( int illum );
   void setWireframe( bool enable );
   void setFogEnable( bool enable );
   void setCulling( Culling cull );
   void setCulling( bool enable );
   void setDepth( Depth depth );
   void setStencil( Stencil stencil );
   void setBlend( Blend blend );
   void setTexture( int stage, ITexture* tex );
   void setTexture( int stage, TexRef ref );

   //std::vector< Triangle3f > createCollisionTriangles() const;
   void flipVertexPosYZ();
   void flipNormals();

   void transformVertices( glm::dmat4 const & m );
   void translateVertices( glm::vec3 const & offset );
   void translateVertices( float x, float y, float z );
   void rotateVertices( float a, float b, float c );
   void colorVertices( uint32_t color );
   void centerVertices();
   void scaleTexture( float u, float v );
   void scaleVertices( float scale = 1.01f );
   void scaleVertices( float sx, float sy, float sz );

//   bool
//   intersectRayWithBoundingBox( Ray3< T > const & ray, MeshIntersectionResult< T > & result,
//                                glm::tmat4x4<T> const & trs ) const;

   bool
   intersectRayWithBoundingBox( Ray3< T > const & ray,
                                MeshIntersectionResult< T > & result ) const;

   bool
   intersectRay( Ray3< T > const & ray,
                 MeshIntersectionResult< T > & result ) const;

//   bool
//   intersectRay( Ray3< T > const & ray,
//                 MeshIntersectionResult< T > & result,
//                 glm::tmat4x4<T> const & modelMat = glm::tmat4x4<T>( T(1) ) ) const;
   /*
   template < typename T >
   bool intersectRay(
         Ray3< T > const & ray,
         glm::tvec3< T >* hitPosition = nullptr,
         uint32_t* bufferIndex = nullptr,
         uint32_t* triangleIndex = nullptr ) const
   {
      auto hitDist = std::numeric_limits< T >::max();
      auto hitPos = glm::tvec3< T >( T(0), T(0), T(0) );

      uint32_t bufIndex = 0;
      uint32_t triIndex = 0;
      bool doesIntersect = false;

      for ( int32_t i = 0; i < getMeshBufferCount(); ++i )
      {
         auto const & p = getMeshBuffer( i );
         if ( !p.isVisible() ) continue; // nothing todo

         glm::tvec3< T > tmpPos;
         uint32_t tmpIndex = 0;
         if ( p.intersectRay( ray, &tmpPos, &tmpIndex ) )
         {
            doesIntersect = true;
            auto dist = glm::length( hitPos - ray.getPos() );
            if ( hitDist > dist )
            {
               hitDist = dist;
               hitPos = hitPos;
               bufIndex = uint32_t( i );
               triIndex = tmpIndex;
            }
         }
      }

      if ( doesIntersect )
      {
         if ( hitPosition ) { *hitPosition = hitPos; }
         if ( bufferIndex ) { *bufferIndex = bufIndex; }
         if ( triangleIndex ) { *triangleIndex = triIndex; }
      }

      return doesIntersect;
   }
*/

   DE_CREATE_LOGGER("de.gpu.SMesh")
   glm::dmat4 ModelMat;
   Box3f BoundingBox;//! Bounding box of this meshbuffer.
   std::string Name;
   std::vector< SMeshBuffer > Buffers;   //! Geometry buffers for this mesh
   bool Visible;

};


// ===========================================================================
struct SMeshTool
// ===========================================================================
{
    DE_CREATE_LOGGER("de.gpu.SMeshTool")
    static void
    transformVertices( SMesh & o, glm::dmat4 const & modelMat = glm::dmat4(1.0) );

    static void
    flipNormals( SMeshBuffer & o );
    static void
    flipWinding( SMeshBuffer & o );

    static void
    flipX(SMesh & o);
    static void
    flipY(SMesh & o);
    static void
    flipZ(SMesh & o);
    static void
    flipXY(SMesh & o);
    static void
    flipYZ(SMesh & o);
    static void
    flipXZ(SMesh & o);
    static void
    flipNormals( SMesh & o );
    static void
    flipWinding( SMesh & o );
    static void
    colorVertices( SMesh & o, uint32_t color );
    static void
    translateVertices( SMesh & o, glm::vec3 const & offset );
    static void
    translateVertices( SMesh & o, float x, float y, float z );
    static void
    rotateVertices( SMesh & o, float a, float b, float c );
    static void
    rotateVertices( SMesh & o, glm::vec3 const & degrees );
    static void
    scaleVertices( SMesh & o, glm::vec3 const & scale );
    static void
    scaleVertices( SMesh & o, float x, float y, float z );
    static void
    centerVertices( SMesh & o );
    static void
    recalculateNormals( SMesh & o );
    static void
    fitVertices( SMesh & o, float maxSize = 1000.0f );
    static void
    removeDoubleVertices( SMesh & mesh );
    static void
    removeDoubleMaterials( SMesh & mesh );
    static void
    removeEmptyMeshBuffer( SMesh & mesh );
};


#endif

} // end namespace de.
