<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>ActiveWallpaper</title>
		<style>
			html,body { height:100%; margin:0; background:#0b0f14; color:#e6eef8; font-family:system-ui, sans-serif; }
			#gl { width:100%; height:100vh; display:block; }
			.ui { position: absolute; left:12px; top:12px; z-index:10; background: rgba(6,10,14,0.6); padding:8px 10px; border-radius:6px; font-size:13px; }
			.ui label{ display:flex; gap:8px; align-items:center; margin-bottom:6px; }
			.ui input[type=range]{ width:140px; }
		</style>
	</head>
<body>
<canvas id="gl"></canvas>
<div class="ui">
	<label>Threshold <input id="thr" type="range" min="0" max="3" step="0.01" value="0.9"></label>
	<label>Intensity <input id="intensity" type="range" min="0" max="4" step="0.01" value="1.6"></label>
	<label>Blur Radius <input id="radius" type="range" min="1" max="30" step="1" value="10"></label>
</div>
  
<!-- Scene vertex shader -->
<script type="x-shader/x-vertex" id="vs-scene">
	attribute vec3 aPosition;
	attribute vec3 aNormal;
	attribute vec2 aUv;

	uniform mat4 uModel;
	uniform mat4 uView;
	uniform mat4 uProj;

	varying vec3 vNormal;
	varying vec3 vWorldPos;
	varying vec2 vUv;

	void main()
	{
		vUv = aUv;
		vec4 world = uModel * vec4(aPosition, 1.0);
		vWorldPos = world.xyz;
		vNormal = mat3(uModel) * aNormal;
		gl_Position = uProj * uView * world;
	}
</script>

<!-- Scene fragment shader: writes HDR-like color (brightness > 1 allowed) -->
<script type="x-shader/x-fragment" id="fs-scene">
	precision mediump float;
	varying vec3 vNormal;
	varying vec3 vWorldPos;
	varying vec2 vUv;
	uniform vec3 uLightPos;
	uniform sampler2D uAlbedo;

	void main()
	{
		vec3 N = normalize(vNormal);
		vec3 L = normalize(uLightPos - vWorldPos);
		float diff = max(dot(N, L), 0.0);

		// base color from a gradient texture
		vec3 base = texture2D(uAlbedo, vUv).rgb;

		// make the cube partially emissive (so bloom shows)
		float emissiveFactor = smoothstep(0.5, 0.0, abs(vUv.x-0.5) * 2.0) * 2.0;
		vec3 emissive = base * emissiveFactor; // can exceed 1.0

		vec3 color = base * (0.2 + 0.9 * diff) + emissive;

		// output high dynamic range color (within 0..>1)
		gl_FragColor = vec4(color, 1.0);
	}
</script>

<!-- Fullscreen quad vertex (for post-process) -->
<script type="x-shader/x-vertex" id="vs-quad">
	attribute vec2 aPos;
	varying vec2 vUv;
	void main()
	{ 
		vUv = aPos * 0.5 + 0.5; 
		gl_Position = vec4(aPos, 0.0, 1.0); 
	}
</script>

<!-- Brightpass + horizontal blur (used for two-pass separable blur) -->
<script type="x-shader/x-fragment" id="fs-bright-h">
	precision mediump float;
	varying vec2 vUv;
	uniform sampler2D uScene;
	uniform float uThreshold;
	uniform float uTexelX;
	uniform int uRadius;

	float weight(float x, float sigma)
	{
		return exp(-(x*x)/(2.0*sigma*sigma));
	}

	void main()
	{
		// bright pass (extract values above threshold)
		vec3 center = texture2D(uScene, vUv).rgb;
		vec3 bright = max(center - vec3(uThreshold), vec3(0.0));

		// separable horizontal blur (approx gaussian)
		float sigma = float(max(1.0, float(uRadius)))/2.0;
		vec3 acc = bright * weight(0.0, sigma);
		float wsum = weight(0.0, sigma);

		for(int i=1; i<=64; i++)
		{
			if (i > uRadius) break;
			float fi = float(i);
			float w = weight(fi, sigma);
			vec2 off = vec2(uTexelX * fi, 0.0);
			acc += texture2D(uScene, vUv + off).rgb * w;
			acc += texture2D(uScene, vUv - off).rgb * w;
			wsum += 2.0 * w;
		}
		gl_FragColor = vec4(acc / max(wsum, 1e-6), 1.0);
	}
</script>

<!-- Vertical blur (reads from horizontal blur target) -->
<script type="x-shader/x-fragment" id="fs-blur-v">
	precision mediump float;
	varying vec2 vUv;
	uniform sampler2D uTex;
	uniform float uTexelY;
	uniform int uRadius;

	float weight(float x, float sigma)
	{
		return exp(-(x*x)/(2.0*sigma*sigma));
	}
	
	void main()
	{
		float sigma = float(max(1.0,float(uRadius)))/2.0;
		vec3 acc = texture2D(uTex, vUv).rgb * weight(0.0, sigma);
		float wsum = weight(0.0, sigma);
		
		for(int i=1; i<=64; i++)
		{
			if (i > uRadius) break;
			float fi = float(i);
			float w = weight(fi, sigma);
			vec2 off = vec2(0.0, uTexelY * fi);
			acc += texture2D(uTex, vUv + off).rgb * w;
			acc += texture2D(uTex, vUv - off).rgb * w;
			wsum += 2.0 * w;
		}
		gl_FragColor = vec4(acc / max(wsum, 1e-6), 1.0);
	}
</script>

<!-- Composite: add blur to original scene -->
<script type="x-shader/x-fragment" id="fs-composite">
	precision mediump float;
	varying vec2 vUv;
	uniform sampler2D uScene;
	uniform sampler2D uBloom;
	uniform float uIntensity;

	// simple reinhard tone map (keeps highlights reasonable)
	vec3 tonemap(vec3 c)
	{
		return c / (1.0 + c);
	}

	void main()
	{
		vec3 scene = texture2D(uScene, vUv).rgb;
		vec3 bloom = texture2D(uBloom, vUv).rgb;
		vec3 result = scene + bloom * uIntensity;
		result = tonemap(result);
		// gamma ~1/2.2
		result = pow(result, vec3(1.0/2.2));
		gl_FragColor = vec4(result, 1.0);
	}
</script>

<script>

	
	/*
	function createShader(vs_src, fs_src)
	{
		let sh=gl.createShader(type);
		gl.shaderSource(sh,src);
		gl.compileShader(sh);
		if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS))
			throw gl.getShaderInfoLog(sh);
		return sh;
	}
	*/


	// --- simple matrix helpers (minimal) ---
	function mulMat(a,b)
	{
		const out = new Float32Array(16);
		for (let i = 0; i < 4; i++)
		{
			for (let j = 0; j < 4; j++)
			{
				let s = 0;
				for (let k = 0; k<4; k++) 
				{
					s += a[k*4 + j] * b[i*4 + k];
				}
				out[i*4 + j] = s;
			}
		}
		return out;
	}
	
	function identity()
	{ 
		const m = new Float32Array(16); 
		m[0] = 1; 
		m[5] = 1; 
		m[10] = 1; 
		m[15] = 1; 
		return m; 
	}
	
	function translate(tx,ty,tz)
	{ 
		const m = identity(); 
		m[12] = tx; 
		m[13] = ty; 
		m[14] = tz; 
		return m; 
	}
	
	function scale(sx,sy,sz)
	{ 
		const m = identity(); 
		m[0] = sx; 
		m[5] = sy; 
		m[10] = sz; 
		return m; 
	}
	
	function rotateY(a)
	{
		const c = Math.cos(a);
		const s = Math.sin(a); 
		const m = identity();
		m[0]=c; 
		m[2]=s; 
		m[8]=-s; 
		m[10]=c; 
		return m;
	}
	
	function perspective(fovy, aspect, near, far)
	{
		const f = 1.0 / Math.tan(fovy * 0.5);
		const nf = 1 / (near - far);
		const m = new Float32Array(16);
		m[0] = f / aspect;
		m[5] = f;
		m[10] = (far + near) * nf;
		m[11] = -1;
		m[14] = (2 * far * near) * nf;
		return m;
	}

	function lookAt(eye, center, up)
	{
		const z0 = eye[0]-center[0]; 
		const z1 = eye[1]-center[1]; 
		const z2 = eye[2]-center[2];
		let zl = Math.hypot(z0,z1,z2); 
		zl = zl ? 1/zl : 1; 
		const zx = z0*zl; 
		const zy = z1*zl;
		const zz = z2*zl;
		const xx = up[1]*zz - up[2]*zy;
		const xy = up[2]*zx - up[0]*zz;
		const xz = up[0]*zy - up[1]*zx;
		let xl = Math.hypot(xx,xy,xz); 
		xl = xl ? 1/xl : 1;
		const rx = xx*xl; 
		const ry = xy*xl;
		const rz = xz*xl;
		const ux = zy*rz - zz*ry;
		const uy = zz*rx - zx*rz;
		const uz = zx*ry - zy*rx;
		const m = identity();
		m[0] = rx; m[1] = ux; m[2] = zx; // note: column-major expectation in our mul order below
		m[4] = ry; m[5] = uy; m[6] = zy;
		m[8] = rz; m[9] = uz; m[10] = zz;
		m[12] = -(rx*eye[0] + ry*eye[1] + rz*eye[2]);
		m[13] = -(ux*eye[0] + uy*eye[1] + uz*eye[2]);
		m[14] = -(zx*eye[0] + zy*eye[1] + zz*eye[2]);
		return m;
	}	

</script>
  
<script>
/*
	=== MAIN ===
*/

(function()
{
	const canvas = document.getElementById('gl');
	const gl = canvas.getContext('webgl', {antialias:true});
	if (!gl)
	{ 
		alert('WebGL not available'); 
		return; 
	}


	function compileShader(type, source, shaderName) 
	{
		const shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);

		const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		if (!success) 
		{
			const typeLabel = type === gl.VERTEX_SHADER ? 'vs' :
							  type === gl.FRAGMENT_SHADER ? 'fs' : 'unknown';
			const log = gl.getShaderInfoLog(shader);
			throw new Error(`[${shaderName}][${typeLabel}] Shader compilation failed:\n${log}`);
		}

		return shader;
	}

	function linkShader(vs, fs)
	{
		let p = gl.createProgram();
		gl.attachShader(p,vs);
		gl.attachShader(p,fs);
		gl.linkProgram(p);
		if (!gl.getProgramParameter(p,gl.LINK_STATUS))
		{
			throw gl.getProgramInfoLog(p);
		}
		return p;
	}
	
	// --- create small gradient texture used as albedo ---
	function makeGradientTexture(gl)
	{
		const size = 256;
		const data = new Uint8Array(size * size * 3);
		for(let y=0;y<size;y++){
		for(let x=0;x<size;x++){
			const t = x / (size-1);
			// left color (warm) -> right color (cool)
			const r = (1.0 - t) * 230 + t * 70;
			const g = (1.0 - t) * 80  + t * 160;
			const b = (1.0 - t) * 40  + t * 230;
			const i = (y*size + x) * 3;
			data[i+0] = r|0; data[i+1] = g|0; data[i+2] = b|0;
		}
		}
		const t = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, t);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, size, size, 0, gl.RGB, gl.UNSIGNED_BYTE, data);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.bindTexture(gl.TEXTURE_2D, null);
		return t;
	}
	
	// --- render targets: sceneRT, ping, pong ---
	function createRT(w, h)
	{
		const tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

		const fbo = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);

		// depth buffer for scene RT
		const rbo = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, rbo);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rbo);

		// cleanup
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		return {tex, fbo, rbo, w, h};
	}

	// [Shader] Scene
	const vs_scene_src = document.getElementById('vs-scene').textContent;
	const fs_scene_src = document.getElementById('fs-scene').textContent;
	const vs_scene = compileShader(gl.VERTEX_SHADER, vs_scene_src, "scene");
	const fs_scene = compileShader(gl.FRAGMENT_SHADER, fs_scene_src, "scene");
	const progScene = linkShader(vs_scene, fs_scene);

	// [Shader] Postprocess programs
	const vs_quad_src = document.getElementById('vs-quad').textContent;
	const fs_brightH_src = document.getElementById('fs-bright-h').textContent;
	const fs_blurV_src = document.getElementById('fs-blur-v').textContent;
	const fs_comp_src = document.getElementById('fs-composite').textContent;

	const vs_quad = compileShader(gl.VERTEX_SHADER, vs_quad_src, "quad");
	const fs_brightH = compileShader(gl.FRAGMENT_SHADER, fs_brightH_src, "brightH");
	const fs_blurV   = compileShader(gl.FRAGMENT_SHADER, fs_blurV_src, "blurV");
	const fs_comp    = compileShader(gl.FRAGMENT_SHADER, fs_comp_src, "comp");

	const progBrightH = linkShader(vs_quad, fs_brightH);
	const progBlurV   = linkShader(vs_quad, fs_blurV);
	const progComp    = linkShader(vs_quad, fs_comp);

	// --- geometry: cube ---
	// cube positions (size 1)
	const positions = new Float32Array([
		// front
		-1, -1,  1,   1, -1,  1,   1,  1,  1,  -1,  1,  1,
		// back
		-1, -1, -1,  -1,  1, -1,   1,  1, -1,   1, -1, -1,
		// top
		-1,  1, -1,  -1,  1,  1,   1,  1,  1,   1,  1, -1,
		// bottom
		-1, -1, -1,   1, -1, -1,   1, -1,  1,  -1, -1,  1,
		// right
		1, -1, -1,   1,  1, -1,   1,  1,  1,   1, -1,  1,
		// left
		-1, -1, -1,  -1, -1,  1,  -1,  1,  1,  -1,  1, -1
	]);

	const normals = new Float32Array([
		// front
		0, 0, 1,  0,0,1,  0,0,1,  0,0,1,
		// back
		0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
		// top
		0,1,0, 0,1,0, 0,1,0, 0,1,0,
		// bottom
		0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
		// right
		1,0,0, 1,0,0, 1,0,0, 1,0,0,
		// left
		-1,0,0,-1,0,0,-1,0,0,-1,0,0
	]);

	const uvs = new Float32Array([
		// each face: same uv
		0,0, 1,0, 1,1, 0,1,
		0,0, 1,0, 1,1, 0,1,
		0,0, 1,0, 1,1, 0,1,
		0,0, 1,0, 1,1, 0,1,
		0,0, 1,0, 1,1, 0,1,
		0,0, 1,0, 1,1, 0,1
	]);

	const indices = new Uint16Array([
		0,1,2,  0,2,3,      4,5,6,  4,6,7,
		8,9,10, 8,10,11,   12,13,14, 12,14,15,
		16,17,18, 16,18,19, 20,21,22, 20,22,23
	]);

	// --- buffers ---
	const bufPos = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, bufPos);
	gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

	const bufNor = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, bufNor);
	gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

	const bufUV = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, bufUV);
	gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);

	const bufIdx = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIdx);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

	// Fullscreen quad for postprocess
	const quadVerts = new Float32Array([-1,-1,  1,-1,  -1,1,   1,1]);
	const quadVBO = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
	gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

	// Create texture
	const albedoTex = makeGradientTexture(gl);

	// resize handling
	function resizeImpl()
	{
		const dpr = window.devicePixelRatio || 1;
		canvas.width = Math.floor(canvas.clientWidth * dpr);
		canvas.height = Math.floor(canvas.clientHeight * dpr);
		const w = canvas.width, h = canvas.height;
		sceneRT = createRT(w,h);
		pingRT  = createRT(w,h);
		pongRT  = createRT(w,h);
	}
	window.addEventListener('resize', resizeImpl);
	resizeImpl();

	// --- attribute locations for scene (we will query & enable per-program) ---
	function bindSceneAttributes(prog)
	{
		const aPos = gl.getAttribLocation(prog, 'aPosition');
		const aNor = gl.getAttribLocation(prog, 'aNormal');
		const aUv  = gl.getAttribLocation(prog, 'aUv');

		// positions
		gl.bindBuffer(gl.ARRAY_BUFFER, bufPos);
		gl.enableVertexAttribArray(aPos);
		gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);

		// normals
		gl.bindBuffer(gl.ARRAY_BUFFER, bufNor);
		gl.enableVertexAttribArray(aNor);
		gl.vertexAttribPointer(aNor, 3, gl.FLOAT, false, 0, 0);

		// uvs
		gl.bindBuffer(gl.ARRAY_BUFFER, bufUV);
		gl.enableVertexAttribArray(aUv);
		gl.vertexAttribPointer(aUv, 2, gl.FLOAT, false, 0, 0);

		// element array
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIdx);
	}

	// attributes for quad
	function bindQuad(prog)
	{
		const aPos = gl.getAttribLocation(prog, 'aPos');
		gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
		gl.enableVertexAttribArray(aPos);
		gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
	}

	// --- uniforms locations ---
	const uniScene = 
	{
		uModel: gl.getUniformLocation(progScene, 'uModel'),
		uView:  gl.getUniformLocation(progScene, 'uView'),
		uProj:  gl.getUniformLocation(progScene, 'uProj'),
		uLightPos: gl.getUniformLocation(progScene, 'uLightPos'),
		uAlbedo: gl.getUniformLocation(progScene, 'uAlbedo')
	};

	const uniBright = {
		uScene: gl.getUniformLocation(progBrightH, 'uScene'),
		uThreshold: gl.getUniformLocation(progBrightH, 'uThreshold'),
		uTexelX: gl.getUniformLocation(progBrightH, 'uTexelX'),
		uRadius: gl.getUniformLocation(progBrightH, 'uRadius')
	};

	const uniBlurV = {
		uTex: gl.getUniformLocation(progBlurV, 'uTex'),
		uTexelY: gl.getUniformLocation(progBlurV, 'uTexelY'),
		uRadius: gl.getUniformLocation(progBlurV, 'uRadius')
	};

	const uniComp = {
		uScene: gl.getUniformLocation(progComp, 'uScene'),
		uBloom: gl.getUniformLocation(progComp, 'uBloom'),
		uIntensity: gl.getUniformLocation(progComp, 'uIntensity')
	};

	// UI controls
	const thrEl = document.getElementById('thr');
	const intensityEl = document.getElementById('intensity');
	const radiusEl = document.getElementById('radius');

	// camera (static look-at the cube)
	const cam = 
	{
		eye: [3.0, 2.0, 4.0],
		center: [0,0,0],
		up: [0,1,0],
		fovy: Math.PI/4
	};

	// simple orbit controls (rotate camera around cube)
	let dragging = false, lastX = 0, lastY = 0;
	let yaw = -0.9, pitch = -0.3, dist = 6.0;
	canvas.addEventListener('mousedown', 
		(e)=>
		{ 
			dragging=true; 
			lastX = e.clientX; 
			lastY = e.clientY; 
		});
		
	window.addEventListener('mouseup', ()=>dragging=false);
	window.addEventListener('mousemove', 
		(e)=>
		{
			if(!dragging) return;
			const dx = e.clientX - lastX, dy = e.clientY - lastY;
			lastX = e.clientX; lastY = e.clientY;
			yaw += dx * 0.005;
			pitch += dy * 0.005;
			pitch = Math.max(-1.2, Math.min(1.2, pitch));
		});
		
	canvas.addEventListener('wheel', 
		(e)=>
		{ 
			e.preventDefault(); 
			dist *= 1 + e.deltaY * 0.001; 
			dist = Math.max(2.0, Math.min(20.0, dist)); 
		});

	document.addEventListener("visibilitychange", 
		() => 
		{
			if (document.hidden) 
			{
				// stop animation
				bShouldRender = false;
			} 
			else 
			{
				// resume animation
				bShouldRender = true;
			}
		}
	);

	// animation loop
	const targetFPS = 20;
	const frameDuration = 1000 / targetFPS;
	let lastTime = 0;
	let bShouldRender = false;
	
	function render(now) 
	{
		const dt = (now - lastTime); // in milliseconds (DOMHighResTimeStamp)
		if (dt >= frameDuration) 
		{
			lastTime = now;
			// draw your frame
		    draw(dt * 0.001);			
		}
		requestAnimationFrame(render);
	}

	requestAnimationFrame(render);



	// draw function: render scene -> bright-pass horiz -> blur vertical -> composite
	function draw(dt)
	{
		// ensure targets match size
		if (canvas.width !== canvas.clientWidth * (window.devicePixelRatio || 1) 
		|| canvas.height !== canvas.clientHeight * (window.devicePixelRatio || 1))
		{
			resizeImpl();
		}

		// update camera eye from yaw/pitch/dist
		const ex = Math.cos(pitch) * Math.cos(yaw) * dist;
		const ez = Math.cos(pitch) * Math.sin(yaw) * dist;
		const ey = Math.sin(pitch) * dist;
		cam.eye = [ex, ey, ez];

		// common matrices
		const proj = perspective(cam.fovy, canvas.width / canvas.height, 0.1, 100.0);
		const view = lookAt(cam.eye, cam.center, cam.up);

		// --- 1) render scene into sceneRT ---
		gl.bindFramebuffer(gl.FRAMEBUFFER, sceneRT.fbo);
		gl.viewport(0,0,sceneRT.w, sceneRT.h);
		gl.enable(gl.DEPTH_TEST);
		gl.clearColor(0.03,0.04,0.06,1.0);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		gl.useProgram(progScene);
		bindSceneAttributes(progScene);

		// model transform: rotate slowly
		const model = mulMat(translate(0,0,0), rotateY(performance.now()*0.0006));

		gl.uniformMatrix4fv(uniScene.uModel, false, model);
		gl.uniformMatrix4fv(uniScene.uView, false, view);
		gl.uniformMatrix4fv(uniScene.uProj, false, proj);
		gl.uniform3fv(uniScene.uLightPos, [5.0, 6.0, 3.0]);

		// bind albedo
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, albedoTex);
		gl.uniform1i(uniScene.uAlbedo, 0);

		// draw cube (24 vertices, 36 indices)
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufIdx);
		gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

		// --- 2) bright-pass + horizontal blur -> pingRT ---
		gl.bindFramebuffer(gl.FRAMEBUFFER, pingRT.fbo);
		gl.viewport(0,0,pingRT.w, pingRT.h);
		gl.disable(gl.DEPTH_TEST);
		gl.clear(gl.COLOR_BUFFER_BIT);

		gl.useProgram(progBrightH);
		bindQuad(progBrightH);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, sceneRT.tex);
		gl.uniform1i(uniBright.uScene, 0);
		gl.uniform1f(uniBright.uThreshold, parseFloat(thrEl.value));
		gl.uniform1f(uniBright.uTexelX, 1.0 / pingRT.w);
		gl.uniform1i(uniBright.uRadius, parseInt(radiusEl.value, 10));

		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

		// --- 3) vertical blur -> pongRT ---
		gl.bindFramebuffer(gl.FRAMEBUFFER, pongRT.fbo);
		gl.viewport(0,0,pongRT.w, pongRT.h);
		gl.clear(gl.COLOR_BUFFER_BIT);

		gl.useProgram(progBlurV);
		bindQuad(progBlurV);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, pingRT.tex);
		gl.uniform1i(uniBlurV.uTex, 0);
		gl.uniform1f(uniBlurV.uTexelY, 1.0 / pongRT.h);
		gl.uniform1i(uniBlurV.uRadius, parseInt(radiusEl.value, 10));

		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

		// --- 4) composite (sceneRT + pongRT bloom) to default framebuffer ---
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.viewport(0,0,canvas.width, canvas.height);
		gl.clear(gl.COLOR_BUFFER_BIT);

		gl.useProgram(progComp);
		bindQuad(progComp);

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, sceneRT.tex);
		gl.uniform1i(uniComp.uScene, 0);

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, pongRT.tex);
		gl.uniform1i(uniComp.uBloom, 1);

		gl.uniform1f(uniComp.uIntensity, parseFloat(intensityEl.value));

		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	}
	
  // expose a minimal API for external shader helpers check (optional)
  window.__WEBGL_ENV = {
    gl,
    progScene, progBrightH, progBlurV, progComp
  };

})(); // eof
</script>
</body>
</html>
